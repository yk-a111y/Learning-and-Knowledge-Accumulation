## Python相关
### Python的数据类型
![[Pasted image 20250401165826.png]]
### Python数据类型判断
![[Pasted image 20250401165935.png]]
### Python 中 `list`、`tuple`、`set` 的底层数据结构是什么？为什么 `tuple` 比 `list` 更快？
list（动态数组，类似 C++ vector）
底层基于 可变数组（动态数组），预分配一定空间，动态扩容时 时间复杂度 O(n)。

tuple（不可变数组）
结构固定，不需要额外存储可变信息，访问速度比 list 快。

tuple 可作为字典的 key，而 list 不能（因为 tuple 是 可哈希的）。

set（哈希表）

去重和快速查找，底层基于 哈希表（dict），查询时间复杂度 O(1)。

```python
my_list = [1, 2, 3]    # 动态数组
my_tuple = (1, 2, 3)   # 静态数组（优化存储）
my_set = {1, 2, 3}     # 哈希表（去重）
```
### Python `dict` 的底层实现是什么？为什么字典查询比列表快？
- **字典（dict）使用哈希表（Hash Table）实现**，查找时间复杂度 **O(1)**。
- **列表（list）使用数组存储，查找需要 O(n)**
- **dict 使用开放地址法解决哈希冲突**，Python 3.6+ 采用 **有序字典（OrderedDict）**。开放地址法的核心思想是：当发生哈希冲突时，通过某种探测(probing)策略在哈希表中寻找其他空闲位置来存储元素
### Python的GC机制是如何的？
Python 使用 **引用计数（Reference Counting）** 作为主要回收机制
当 **引用数降为 0** 时，Python 释放对象
**循环引用** 通过 **垃圾回收器（GC，Generational GC）** 处理
## 项目 & 实习相关
## 算法题
### 两数之和
```python
# 输出：nums = [2,7,11,15], target = 9
# 输入：[0,1]
class Solution:
    def twoSum(self, nums: List[int], target: int) -> List[int]:
        hashset={}
        for i in range(len(nums)):
            if hashset.get(target-nums[i]) is not None :
                return [hashset.get(target-nums[i]),i]
            hashset[nums[i]]=i
```
### 全排列
```python
# 输入：[1,2,3]
# 输出：[ [1,2,3], [1,3,2], [2,1,3], [2,3,1], [3,1,2], [3,2,1] ]
class Solution:
    def permute(self, nums):
        result = []
        self.backtracking(nums, [], [False] * len(nums), result)
        return result

    def backtracking(self, nums, path, used, result):
        if len(path) == len(nums):
            result.append(path[:])
            return
        for i in range(len(nums)):
            if used[i]:
                continue
            used[i] = True
            path.append(nums[i])
            self.backtracking(nums, path, used, result)
            path.pop()
            used[i] = False
```