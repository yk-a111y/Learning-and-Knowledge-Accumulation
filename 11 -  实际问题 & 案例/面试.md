
# 数字人编辑器

数字人选择Fabric的原因：https://juejin.cn/post/7243725952789217317  (2D图形库优劣)

## 历史记录
历史记录优化主要目的在于：画面元素过多，undo/redo会造成画布卡顿，尤其是在连续多次点击的情况下，极端条件会导致浏览器崩溃。

### 分层缓存
将画布元素分为：**静态内容**缓存层（背景、数字人、文本）、**动态内容**缓存层（直播间装饰元素）、合成层（将动静二者结合，显示到前台）
```js
class LayerRender {
  constructor(bufferSystem) {
	this.bufferSystem = bufferSystem;
	this.staticElements = []; // 不常变化的元素
	this.dynamicElements = []; // 经常变化的元素
  };

  // 🌟 分层渲染，只重绘变化的层
  render() {
	// 静态层（很少重绘）
	if (this.bufferSystem.staticBufferDirty) {
		this.renderStaticLayer();
		this.bufferSystem.staticBufferDirty = false;
	}
	
	// 动态层（需要重绘时才重绘）
	if (this.bufferSystem.dynamicBufferDirty) {
		this.renderDynamicLayer();
		this.bufferSystem.dynamicBufferDirty = false;
	}
	
	// 合成最终画面
	this.compositeLayer();
  }

  compositeLayer() {
    const ctx = this.bufferSystem.compositeBuffer.ctx;
    ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height);
        
	// 合成各层
	ctx.drawImage(this.bufferSystem.staticBuffer.canvas, 0, 0);
	ctx.drawImage(this.bufferSystem.dynamicBuffer.canvas, 0, 0);
        
	// 显示到前台
	this.editor.displayCtx.clearRect(0, 0, this.editor.displayCanvas.width, this.editor.displayCanvas.height);
	this.editor.displayCtx.drawImage(this.bufferSystem.compositeBuffer.canvas, 0, 0);
    }
}
```

### 智能 & 离屏 Canvas
创建一个离屏Canvas，宽高与compositeBuffer.canvas相同。将完整的缓存数据保存到离屏Canvas中，真正需要展示的时候，直接调用一次`drawImage`方法，提高效率。

使用离屏canvas并不是双缓冲，而是把离屏canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用canvas的API的消耗

绘制时间较长导致了闪屏，解决方法就是新建一个 canvas 作为 **缓存 canvas**，通过 缓存 canvas 完成绘制过程，绘制完成后，直接将 缓存 canvas 复制到原来的 canvas
```js
updateCanvas(){
    const canvas = document.getElementById('canvas'); // 获取页面中的 canvas
    const ctx = canvas.getContext('2d');
    
    const tempCanvas = document.createElement('canvas'); // 新建一个 canvas 作为缓存 canvas
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = 1448; tempCanvas.height = 750; // 设置宽高

    // 开始绘制
    tempCtx.drawImage(bg,0,0); // 背景
    ... // 省略其他绘制过程
    
    // 缓存 canvas 绘制完成
    
    ctx.clearRect(0,0,1448,750); // 清空旧 canvas
    ctx.drawImage(tempCanvas,0,0); // *关键代码：将缓存 canvas 复制到旧的 canvas
}
```

离屏canvas还有一个**注意事项**，如果你做的效果是会将对象不停地创建和销毁，请慎重使用离屏canvas；

因为如果这样绑定，当对象被销毁时，离屏canvas也会被销毁，而大量的离屏canvas不停地被创建和销毁，会导致canvas buffer耗费大量GPU资源，容易造成浏览器崩溃或者严重卡帧现象。解决办法就是弄一个离屏canvas数组，预先装进足够数量的离屏canvas，仅将仍然存活的对象缓存起来，当对象被销毁时，再解除缓存。这样就不会导致离屏canvas被销毁了。

“-------------------------------------------------------------------------”

业内也有`增量存储历史记录`的方案，即每次小变动不存储整个Canvas数据，只对指定objectId的object做变化，节省大量绘制时间。
## 音频波峰
## AI配音和字幕切割
## 图片优化策略
从 [[2- 前端性能优化#图片懒加载 | 图片懒加载]] 开始
## 通用资源懒加载库
[[2- 前端性能优化#通用资源懒加载库 | 通用资源懒加载库]]
# 云小店
## 风控
### 距离风控
### 电话风控
## 地图瓦片式渲染

# FlowScript插件
## MV3热更新
## 画布与handler
## 工作流引擎
## JS handler
## 防跨域代码注入
# CodeGen_Vanilla
详见 [[CodeGen_Vanilla | P2C平台_CodeGen]]
# 前端监控平台
详见 [[1 - 监控流程设计 | 监控流程设计]]