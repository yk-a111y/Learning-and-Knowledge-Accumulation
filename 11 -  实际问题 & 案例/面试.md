
# 数字人编辑器

数字人选择Fabric的原因：https://juejin.cn/post/7243725952789217317  (2D图形库优劣)

## 历史记录

## 离屏Canvas

使用离屏canvas并不是双缓冲，而是把离屏canvas当成一个缓存区。把需要重复绘制的画面数据进行缓存起来，减少调用canvas的API的消耗

绘制时间较长导致了闪屏，解决方法就是新建一个 canvas 作为 **缓存 canvas**，通过 缓存 canvas 完成绘制过程，绘制完成后，直接将 缓存 canvas 复制到原来的 canvas
```js
updateCanvas(){
    const canvas = document.getElementById('canvas'); // 获取页面中的 canvas
    const ctx = canvas.getContext('2d');
    
    const tempCanvas = document.createElement('canvas'); // 新建一个 canvas 作为缓存 canvas
    const tempCtx = tempCanvas.getContext('2d');
    tempCanvas.width = 1448; tempCanvas.height = 750; // 设置宽高

    // 开始绘制
    tempCtx.drawImage(bg,0,0); // 背景
    ... // 省略其他绘制过程
    
    // 缓存 canvas 绘制完成
    
    ctx.clearRect(0,0,1448,750); // 清空旧 canvas
    ctx.drawImage(tempCanvas,0,0); // *关键代码：将缓存 canvas 复制到旧的 canvas
}
```

离屏canvas还有一个**注意事项**，如果你做的效果是会将对象不停地创建和销毁，请慎重使用离屏canvas；

因为如果这样绑定，当对象被销毁时，离屏canvas也会被销毁，而大量的离屏canvas不停地被创建和销毁，会导致canvas buffer耗费大量GPU资源，容易造成浏览器崩溃或者严重卡帧现象。解决办法就是弄一个离屏canvas数组，预先装进足够数量的离屏canvas，仅将仍然存活的对象缓存起来，当对象被销毁时，再解除缓存。这样就不会导致离屏canvas被销毁了。
## 音频波峰
## AI配音和字幕切割
## 图片优化策略
从 [[2- 前端性能优化#图片懒加载 | 图片懒加载]] 开始
## 通用资源懒加载库
[[2- 前端性能优化#通用资源懒加载库 | 通用资源懒加载库]]
# 云小店
## 风控
### 距离风控
### 电话风控
## 地图瓦片式渲染

# FlowScript插件
## MV3热更新
## 画布与handler
## 工作流引擎
## JS handler
## 防跨域代码注入
# CodeGen_Vanilla
## s