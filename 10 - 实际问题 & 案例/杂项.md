# 精确计算单个请求的响应时间
## TTFB & server-timing
TTFB 是从发送请求到接收到第一个字节的时间，包含了网络延迟、DNS 解析、连接建立、请求到达服务器并返回第一个字节的整个过程。所以不能直接反映`数据传输本身的耗时`因为他还包含了`服务器处理的时间`

server-timing放在响应头中，记录了后端服务执行时的性能指标（数据库查询、业务逻辑处理）。返回的格式如下：`Server-Timing: processing;dur=45, db;dur=30` 表示后端处理是45ms，数据查询为30ms。

TTFB - serverTiming = RTT （往返总时间）；所以单程传输时间为RTT / 2
## 具体应用场景

### 服务端时间校准

对于时间精度高的场景，比如API全链路监控，最后整体绘制出来的全链路图直接客户端的访问时间点变成了未来的时间点，这样是不可行的。

通过js调用new Date() 获取的时间，是当前设备的机器时间，而不同设备和地区的时间可能是不一样的，对此js获取的机器时间是个不准确的时间。

Http响应头的字段Date，记录的是服务端发送资源时的服务器时间

![[Pasted image 20250103110831.png]]

在SDK进行初始化时，发送一个简单的请求上报给服务端，从而获取返回的Date值后计算Diff差值存储在本地。这样做可以==比较趋近==服务器的真实时间，比较趋近的原因是因为还有一个单程传输的耗时误差。

这个误差就可以用 (TTFB - serverTiming) / 2来修正。

# Service Worker 实现首页秒开

[[1- JS基础#Service Worker | Service Worker基础]]
[[3- 浏览器原理#Service Worker Cache | Service Cache介绍]]

第一次访问的页面（如首页）没有预加载，可以使用Stale-While-Revalidate 加速页面访问，策略分 3 步
1. 在收到页面请求时首先检查缓存，如果命中缓存就直接从缓存中返回给用户
2. 将缓存返回用户的同时，在后台异步发起网络请求，尝试获取资源的最新版本
3. 获取成功后更新缓存，下次使用
![[Pasted image 20250104160219.png]]
## 拦截修改Response对象
使用 event.respondWith 可以在 fetch 事件中拦截网络请求并提供自定义响应，一旦调用浏览器会等待提供的 Promise 解析，并将其结果作为响应返回给发起请求的代码
```js
self.addEventListener('fetch', event => {
  // 过滤非页面请求
  const url = new URL(event.request.url);
  if (!url.pathname.startsWith('/page/')) return;
  
  event.respondWith(
    caches.match(event.request) // 尝试匹配缓存
      .then(cachedResponse => {
        if (cachedResponse) {
          return cachedResponse; // 缓存命中，返回缓存内容
        }
        // 缓存未命中，从网络获取
        return fetch(event.request);
      })
  );
});
```
## Clone Response对象缓存
`const responseToCache = networkResponse.clone();`
## waitUntil确保异步任务完成
Service Worker 事件都是异步的，浏览器可能在这些异步操作完成之前终止 Service Worker，导致关键任务（如缓存资源或清理旧缓存）无法正确完成。

`event.waitUntil`可以高速浏览器要等待某个Promise完成后，才终止service worker
```js
// 比如在激活阶段，通常需要清理旧缓存
self.addEventListener('activate', event => {
  console.log('[Service Worker] Activate Event');
  const cacheWhitelist = ['my-cache-v2'];
  // 不使用waitUntil的话，很可能在清理结束之前就关闭了service worker
  event.waitUntil(
    caches.keys().then(cacheNames => {
      return Promise.all(
        cacheNames.map(cacheName => {
          if (!cacheWhitelist.includes(cacheName)) {
            console.log(`[Service Worker] Deleting old cache: ${cacheName}`);
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
});
```
## Stale-While-Revalidate实现
详见react-comp对service-worker的处理
> 开发时要注意，service-worker调整 update on reload，不然会出现更新的worker不生效

## Service Worker的未来
 2024 年度全球技术大会 TPAC在9月讨论了《提升 ServiceWorker 性能的新特性》专题，其中有hen
# 控制高并发请求的数量
前端高并发场景：
- 移动端H5开发lottie动效，一个动效就要请求70张图片。但Webview限制并发请求数，会导致部分资源请求失败
- 多接口的业务开发
## 初版
这个问题可以通过实现并发请求函数concurrencyRequest(urls, maxNum)解决。其中，maxNum为最大并发数，请求完成后按照urls的顺序依次打出。
```js
const urls = [];
for (let i = 1; i <= 20; i++) {
  urls.push(`https://jsonplaceholder.typicode.com/todos/${i}`);
}

const preLoad = (maxNum = 5, urls) => {
  let count = 0;

  const createTask = () => {
    if (count < maxNum) {
      const url = urls.pop();
      if (url) {
        loader(url).finally(taskFinish);
        count++;
        createTask();
      }
    }
  };

  const taskFinish = () => {
    count--;
    createTask();
  };

  createTask();
};

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

const loader = async (url) => {
  await delay(2000);
  const res = await fetch(url).then((res) => res.json());
  console.log("res", res);
  return res;
};

preLoad(5, urls); // 每5个一组去请求
```
## 边界条件
上述代码基本满足需求，但有些边界条件未考虑到，重新设计的代码如下：
```js
const urls = [];
for (let i = 1; i <= 20; i++) {
  urls.push(`https://jsonplaceholder.typicode.com/todos/${i}`);
}

const concurrencyRequest = (urls, maxNum = 5) => {
  return new Promise((resolve) => {
    if (urls.length === 0) {
      resolve([]);
      return;
    }
    const results = [];
    let index = 0; // 请求结果下标
    let count = 0; // 请求完成数量

    // 边界条件取urls和并发数的小值
    const amount = Math.min(urls.length, maxNum);
    for (let i = 0; i < amount; i++) {
      request();
    }

    async function request() {
      if (index === urls.length) return;
      const i = index;
      const url = urls[index];
      index++;
      console.log(url);

      try {
        await delay(1000);
        const resp = await fetch(url);
        results[i] = resp;
      } catch (err) {
        results[i] = err;
      } finally {
        count++;
        if (count === urls.length) {
          console.log("完成了 Finished！！！！！！！");
          resolve(results);
        }
        request();
      }
    }
  });
};

function delay(ms) {
  return new Promise((resolve) => setTimeout(resolve, ms));
}

concurrencyRequest(urls, 5).then((res) => {
  console.log(res);
});
```
## p-limit
也可以借鉴开源库p-limit的简易实现
```js
class PLimit {
    constructor(concurrency) {
        this.concurrency = concurrency;
        this.activeCount = 0;
        this.queue = [];
        
        return (fn, ...args) => {
            return new Promise(resolve => {
               this.enqueue(fn, resolve, args);
            });
        }
    }
    
    enqueue(fn, resolve, args) {
        this.queue.push(this.run.bind(this, fn, resolve, args));

        (async () => {
            await Promise.resolve();
            if (this.activeCount < this.concurrency && this.queue.length > 0) {
                this.queue.shift()();
            }
        })();
    }
    
    async run(fn, resolve, args) {
        this.activeCount++;

        const result = (async () => fn(...args))();

        resolve(result);

        try {
            await result;
        } catch {
        }

        this.next();
    }
    
    next() {
        this.activeCount--;

        if (this.queue.length > 0) {
            this.queue.shift()();
        }
    }
}
```
真正的p-limit的queue引入了开源库，详见[[1- JS基础#实现一个Queue | Queue]]
# 字体性能优化指南
# 服务端渲染之流式渲染