# 精确计算单个请求的响应时间
## TTFB & server-timing
TTFB 是从发送请求到接收到第一个字节的时间，包含了网络延迟、DNS 解析、连接建立、请求到达服务器并返回第一个字节的整个过程。所以不能直接反映`数据传输本身的耗时`因为他还包含了`服务器处理的时间`

server-timing放在响应头中，记录了后端服务执行时的性能指标（数据库查询、业务逻辑处理）。返回的格式如下：`Server-Timing: processing;dur=45, db;dur=30` 表示后端处理是45ms，数据查询为30ms。

TTFB - serverTiming = RTT （往返总时间）；所以单程传输时间为RTT / 2
## 具体应用场景

### 服务端时间校准

对于时间精度高的场景，比如API全链路监控，最后整体绘制出来的全链路图直接客户端的访问时间点变成了未来的时间点，这样是不可行的。

通过js调用new Date() 获取的时间，是当前设备的机器时间，而不同设备和地区的时间可能是不一样的，对此js获取的机器时间是个不准确的时间。

Http响应头的字段Date，记录的是服务端发送资源时的服务器时间

![[Pasted image 20250103110831.png]]

在SDK进行初始化时，发送一个简单的请求上报给服务端，从而获取返回的Date值后计算Diff差值存储在本地。这样做可以==比较趋近==服务器的真实时间，比较趋近的原因是因为还有一个单程传输的耗时误差。

这个误差就可以用 (TTFB - serverTiming) / 2来修正。

# Service Worker 实现首页秒开
第一次访问的页面（如首页）没有预加载，可以使用Stale-While-Revalidate 加速页面访问，策略分 3 步
1. 在收到页面请求时首先检查缓存，如果命中缓存就直接从缓存中返回给用户
2. 将缓存返回用户的同时，在后台异步发起网络请求，尝试获取资源的最新版本
3. 获取成功后更新缓存，下次使用