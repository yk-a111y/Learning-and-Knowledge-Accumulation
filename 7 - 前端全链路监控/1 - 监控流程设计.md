![[Pasted image 20250107150942.png]]
## 监控的初始化
### 重写浏览器事件
监控平台一般需要对一些浏览器原生事件重写，这样做的原因是因为：监控代码需要与业务代码`解耦`，故将事件的监控逻辑放在事件捕获阶段执行，这样即可保证对`业务代码零侵入` & `监控全面性`

具体代码
```ts
// 定义通用的事件注册逻辑
function on (target: Window | Document, eventName: string, handler: Function, options = false) {
	target.addEventListener(eventName, handler, options);
}

/* 
	原生事件的监听
	click -- 加节流监听，避免上报过多数据
	load -- 整个页面及所有依赖资源都加载完成时触发
	beforeunload -- 用户准备离开页面时触发，页面生命周期的最后一个可捕获的时机
	hashchange -- 监听hash模式下路由的变化
	offline & online -- 监听网络开启 & 关闭
*/
function listenerError (type) {
	// 监听error事件，并使用eventBus发送事件, true代表在事件捕获阶段执行
	on(_global, 'error', function(e: ErrorEvent){ eventBus.runEvent(type, e) }, true)
}

function listenUnhandledrejection (type) {
	// 监听Promise异常，并使用eventBus发送事件
	on(_global, 'unhandledrejection', function(ev: PromiseRejectionEvent){ eventBus.runEvent(type, ev) }, true)
}


/* 
	原生事件的重写
*/
function replaceConsoleError (type) {
	// 重写console.error方法
	replaceAop(console, 'error', (originalFn) => {
		return function(this, ...args) {
			// 避免监控系统自身的错误日志造成死循环
			if (
				!(args[0] && args[0].slice && args[0].slice(0, 12) === '@web-tracing')
			) {
				eventBus.runEvent(type, args)
			}

			originalError.apply(this, args)
		}
	})
}
```
### 向服务端发送数据
### 网络监听
### 初始化设备信息