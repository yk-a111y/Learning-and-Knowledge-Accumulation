![[Pasted image 20250107150942.png]]
## 监控的初始化
### 重写浏览器事件
监控平台一般需要对一些浏览器原生事件重写，这样做的原因是因为：监控代码需要与业务代码`解耦`，故将事件的监控逻辑放在事件捕获阶段执行，这样即可保证对`业务代码零侵入` & `监控全面性`

具体代码，分为监听和重写两种，有些只关心`事件`发生时机，那么监听即可；针对需要在某些`方法`执行前后做事情的情况，需要重写。
```ts
// 定义通用的事件注册逻辑
function on (target: Window | Document, eventName: string, handler: Function, options = false) {
	target.addEventListener(eventName, handler, options);
}

/* 
	原生事件的监听，除error和unhandledrejection外，还有：
		click -- 加节流监听，避免上报过多数据
		load -- 整个页面及所有依赖资源都加载完成时触发
		beforeunload -- 用户准备离开页面时触发，页面生命周期的最后一个可捕获的时机
		hashchange -- 监听hash模式下路由的变化
		popstate -- 监听History模式下页面的前进/后退
		offline & online -- 监听网络开启 & 关闭
*/
function listenerError (type) {
	// 监听error事件，并使用eventBus发送事件, true代表在事件捕获阶段执行
	on(_global, 'error', function(e: ErrorEvent){ eventBus.runEvent(type, e) }, true)
}

function listenUnhandledrejection (type) {
	// 监听Promise异常，并使用eventBus发送事件
	on(_global, 'unhandledrejection', function(ev: PromiseRejectionEvent){ eventBus.runEvent(type, ev) }, true)
}


/* 
	原生事件的重写，除了console.error外，还有：
		XMLHttpRequest.open -- XMLHTTPRequest打开时，能收集到请求的配置信息
		XMLHttpRequest.send -- XMLHTTPRequest发送时，收集请求体和 XHR 实例
		fetch -- fetch请求方法
		replaceState -- 添加新的历史记录
		pushState -- 替换当前历史记录
*/
function replaceConsoleError (type) {
	// 重写console.error方法
	replaceAop(console, 'error', (originalFn) => {
		return function(this, ...args) {
			// 避免监控系统自身的错误日志造成死循环
			if (
				!(args[0] && args[0].slice && args[0].slice(0, 12) === '@web-tracing')
			) {
				eventBus.runEvent(type, args)
			}
			// 调用原方法，即console.error本体
			originalError.apply(this, args)
		}
	})
}

/**
 * 重写对象上面的某个属性
 * @param source 需要被重写的对象
 * @param name 需要被重写对象的key
 * @param replacement 以原有的函数作为参数，执行并重写原有函数
 * @param isForced 是否强制重写（可能原先没有该属性）
 */
function replaceAop(source, name, replacement, isForced = false) {
	if (source === undefined) return;
	
	if (name in source || isForced) {
		const original = source[name];
		const wrapped = replacement(original);
		
		if (isFunction(wrapped)) {
	      source[name] = wrapped
	    }
	}
}
```

### 初始化设备信息
通过初始化baseInfo类，创建设备的基础信息和Base数据，代码如下：
```js
class BaseInfo {
	public base;
	public pageId;
	private sdkUserUuid = '';
	private device;
	// 基础信息是否初始化成功
	public _initSuccess = false
	
	constructor() {
		this.pageId = uuid();// 当前应用ID，在整个页面生命周期内不变，单页应用路由变化也不会改变；加载SDK时创建且只创建一次
		
		this.initSdkUserUuid()
			.then(
				this.initDevice();
		        this.initBase();
			)
			.finally(
				this._initSuccess = true
			    sendData.emit([])
			)
	}

	private initSdkUserUuid() {
		return isTestEnv
			? Promise.resolve().then(() => {
				this.sdkUserUuid = '_unit-test-id'
				options.value.sdkUserUuid = '_unit-test-id'
			  })
			: load({})
				.then((fp: any) => fp.get()) // load为获取设备指纹的方法，用户未登录的情况下最大限度标明用户唯一身份
				.then((result) => {
					const visitorId = result.visitorId;
					this.sdkUserUuid = visitorId;
					options.value.sdkUserUuid = visitorId;
				})
	}

	private initDevice() {
		const { screen } = getGlobal() // getGlobal => 获取当前环境的全局变量
	    const { clientWidth, clientHeight } = document.documentElement
	    const { width, height, colorDepth, pixelDepth } = screen
	    let deviceId = getCookieByName(DEVICE_KEY)
	    if (!deviceId) {
	      deviceId = `t_${uuid()}`
	      document.cookie = `${DEVICE_KEY}=${deviceId};path=/;`
	    }

		this.device = {
		  deviceId, // id
	      clientHeight, // 网页可见区高度
	      clientWidth, // 网页可见区宽度
	      colorDepth, // 显示屏幕调色板的比特深度
	      pixelDepth, // 显示屏幕的颜色分辨率
	      screenWidth: width, // 显示屏幕的宽度
	      screenHeight: height, // 显示屏幕的高度
	      vendor: navigator.vendor, // 浏览器名称
	      platform: navigator.platform // 浏览器平台的环境,不是电脑系统的x64这样的(浏览器平台的环境可能是x32)
	    }
	}

	private initBase() {
		// 与一般业务上理解的sessionId做区分,此session与业务无关,单纯就是浏览器端和后端直接的联系
		const sessionId = getSessionId();
		let ip = '';

		this.base = computed(() => ({
	      ...this.device!,
	      userUuid: options.value.userUuid,
	      ext: options.value.ext,
	      appName: options.value.appName,
	      appCode: options.value.appCode,
	      sdkUserUuid: this.sdkUserUuid,
	      pageId: this.pageId,
	      sdkVersion: SDK_VERSION,
	      sessionId,
	      ip
	    }))
	}
}
```

### 向服务端发送数据
```js
class SendData {
  private events = [] // 批次队列
  private timeoutID: NodeJS.Timeout | undefined // 延迟发送ID

  private send() {
    if (!this.events.length) return;
    
    // 选取首部的部分数据来发送,performance会一次性采集大量数据追加到events中
    const sendEvents = this.events.slice(0, options.value.cacheMaxLength) // 需要发送的事件
	this.events = this.events.slice(options.value.cacheMaxLength) // 剩下待发的事件

	// 构建发送参数
	const time = getTimestamp();
	const sendParams = computed(() => {
	  baseInfo: {
	    ...baseInfo.base?.value,
	    sendTime: time,
	    userUuid: options.value.userUuid
	  },
	  eventInfo: map(sendEvents, (e: any) => {
        e.sendTime = time
        return e
      })
	})

	// 本地化拦截, 如果开启了本地化存储，将数据存储到 localStorage
	if (options.value.localization) {
	  const success = LocalStorageUtil.setSendDataItem(
        SDK_LOCAL_KEY,
        sendParams.value
      );
      
	  // 如果存储失败，触发溢出回调
	  if (!success) options.value.localizationOverFlow(sendParams.value)
      return
	}

	// 经过前置钩子处理的最终数据
    const afterSendParams = executeFunctions(
      options.value.beforeSendData,
      false,
      sendParams.value
    )
    if (isFlase(afterSendParams)) return
    if (!this.validateObject(afterSendParams, 'beforeSendData')) return

	debug('send events', sendParams.value);

	this.executeSend(options.value.dsn, afterSendParams).then((res: any) => {
	  // 执行所有「发送后」Hook
      executeFunctions(options.value.afterSendData, true, {
        ...res,
        params: afterSendParams
      })
    })

	// 如果一次性发生的事件超过了阈值(cacheMaxLength)，那么这些经过裁剪的事件列表剩下的会直接发，并不会延迟等到下一个队列
	if (this.events.length) {
      nextTime(this.send.bind(this)) // 继续传输剩余内容,在下一个时间择机传输
    }
  }

  private executeSend(url: string, data) {
    let sendType = 1;
    if (options.value.sendTypeByXmlBody) {
      // 强制指定 xml body 形式
      sendType = 3
    } else if (_global.navigator) {
      // sendBeacon 最大64kb
      sendType = isObjectOverSizeLimit(data, 60) ? 3 : 1
    } else {
      // img 限制在 2kb
      sendType = isObjectOverSizeLimit(data, 2) ? 3 : 2
    }

	return new Promise(resolve => {
      switch (sendType) {
        case 1:
          resolve({ sendType: 'sendBeacon', success: sendByBeacon(url, data) })
          break
        case 2:
          sendByImage(url, data).then(() => {
            resolve({ sendType: 'image', success: true })
          })
          break
        case 3:
          sendByXML(url, data).then(() => {
            resolve({ sendType: 'xml', success: true })
          })
          break
      }
    })
  }
}

// 选取执行发送代码的理想时间
const nextTime =
  window.requestIdleCallback ||
  window.requestAnimationFrame ||
  (callback => setTimeout(callback, 17))
```

发送数据的三种方式
详细描述见：[[2 - 数据结构设计#监控上报时机|监控上报时机]]

sendBeacon
```js
export function sendByBeacon(url: string, data: any) {
  return navigator.sendBeacon(url, JSON.stringify(data))
}
```

Img
```js
export const sendReaconImageList = []

export function sendByImage(url: string, data: any): Promise<void> {
  return new Promise(resolve => {
    const beacon = new Image()
    beacon.src = `${url}?v=${encodeURIComponent(JSON.stringify(data))}`
    sendReaconImageList.push(beacon)
    beacon.onload = () => {
      // 发送成功
      resolve()
    }
    beacon.onerror = function () {
      // 发送失败
      resolve()
    }
  })
}
```
XML
```js
export function sendByXML(url: string, data: any): Promise<void> {
  return new Promise(resolve => {
    const xhr = new XMLHttpRequest()
    xhr.open('post', url)
    xhr.setRequestHeader('content-type', 'application/json')
    xhr.send(JSON.stringify(data))
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        resolve()
      }
    }
  })
}
```
### 网络监听
当处于断网状态下的所有埋点事件都无效（认为此时采集的数据大部分是无效的）
```js
class LineStatus {
  onLine = true
  
  constructor() {
    this.init()
  }

  init() {
	eventBus.addEvent({
      type: EVENTTYPES.OFFLINE,
      callback: e => {
        if (e.type === 'offline') {
          debug('网络断开')
          this.onLine = false
        }
      }
    });
    
    eventBus.addEvent({
      type: EVENTTYPES.ONLINE,
      callback: e => {
        if (e.type === 'online') {
          debug('网络连接')
          this.onLine = true
        }
      }
    })
  }
}
```

## 监控平台处理错误
核心逻辑
```js
function initError() {
  if (!options.value.error.core) return // 1. 为启用错误监控

  // 2. 批量处理错误：script.onError link.onError img.onError
  if (options.value.scopeError) {
    initBatchError()
    // 页面卸载前发送缓存的错误 以防缓存池内的错误丢失
    eventBus.addEvent({
      type: EVENTTYPES.BEFOREUNLOAD,
      callback: () => {
        batchError.sendAllCacheError()
      }
    })
  }

  // 3. 资源加载错误监控：reject处理过的错误不进行捕获
  eventBus.addEvent({
    type: EVENTTYPES.ERROR,
    callback: (e: ErrorEvent) => {
      const errorInfo = parseErrorEvent(e)
      if (isIgnoreErrors(errorInfo)) return // 如果是忽略的错误，不上报
      emit(errorInfo)
    }
  })

  // 4. Promise 未捕获异常监控
  eventBus.addEvent({
    type: EVENTTYPES.UNHANDLEDREJECTION,
    callback: (e: PromiseRejectedResult) => {
      const errorInfo = parseErrorEvent(e)
      if (isIgnoreErrors(errorInfo)) return
      emit(errorInfo)
    }
  })

  // 5. console.error 监控
  eventBus.addEvent({
    type: EVENTTYPES.CONSOLEERROR,
    callback: e => {
      const errorInfo = parseError(e)
      if (isIgnoreErrors(errorInfo)) return
      emit({ eventId: SENDID.CODE, ...errorInfo })
    }
  })
}
```
### 处理批量错误

```js
const GROUPARRAYKEY = ['errMessage', 'eventId', 'requestUrl']
const SETTIMEA = 2000 // A栈检查时间：2s
const SETTIMEB = 20000 // B栈检查时间：20s
const MAXLENGTHA = 5 // 批量错误阈值 5 个

class BatchError {
  constructor() {
    this.cacheErrorA = [] // A栈存储临时错误
    this.cacheErrorB = [] // B栈存储批量错误

	// 防抖2s，检查A栈
    this.throttleProxyAddCacheErrorA = debounce(
      this.proxyAddCacheErrorA,
      SETTIMEA
    )
    // 防抖20s，检查B栈
    this.throttleProxyAddCacheErrorB = throttle(
      this.proxyAddCacheErrorB,
      SETTIMEB
    )
  }

  // 每2s触发一次该方法，检查cacheErrorA栈中的错误
  proxyAddCacheErrorA() {
    let len = this.cacheErrorA.length;
    if (!len) return;

	const arr = groupArray(this.cacheErrorA, ...GROUPARRAYKEY)
    const arrA = arr.filter(item => item.length < MAXLENGTHA) // 2s触发小于5次
    const arrB = arr.filter(item => item.length >= MAXLENGTHA) // 2s触发大于5次
    
	// 处理普通错误，直接发送
	if (arrA.length) {
      sendData.emit(arrA.flat(Infinity))
    }

	// 处理批量错误：合并后放入B栈
    if (arrB.length) {
      const arrBsum: any[] = []
      arrB.forEach(item => {
        const sumItem = item[0]
        sumItem.batchError = true
        sumItem.batchErrorLength = item.length
        sumItem.batchErrorLastHappenTime = item[item.length - 1].triggerTime
        arrBsum.push(sumItem)
      })
      this.cacheErrorB.push(...arrBsum)
      this.throttleProxyAddCacheErrorB()
    }

    // 内存友好型数组清空的写法，内存释放更平滑
    // this.cacheErrorA = [] 会触发大量内存回收，内存使用突增，数据量大时会造成页面卡顿
	while (len--) {
      this.cacheErrorA.shift()
    }
  }
  
  // 每20s触发一次该方法，检查cacheErrorB栈中的错误
  proxyAddCacheErrorB() {
    let len = this.cacheErrorB.length
    if (!len) return
    const arr = groupArray(this.cacheErrorB, ...GROUPARRAYKEY)

	// 清空B栈
	while (len--) {
      this.cacheErrorB.shift()
    }

	// 将区间报错合并
    const emitList: any[] = []
    arr.forEach((itemList: any[]) => {
      const sumItem = itemList[0]
      if (itemList.length > 1) {
        sumItem.batchErrorLength = itemList.reduce(
          (p, item) => (p += item.batchErrorLength),
          0
        )
        sumItem.batchErrorLastHappenTime =
          itemList[itemList.length - 1].triggerTime
      }
      emitList.push(sumItem)
    })
    sendData.emit(emitList)
  }

  // 用户突然关闭页面时调用此方法集成错误并发送
  sendAllCacheError() {
    const errInfoList = this.cacheErrorA.concat(this.cacheErrorB)
    const arr = groupArray(errInfoList, ...GROUPARRAYKEY)
    const arrA = arr.filter(item => item.length < MAXLENGTHA)
    const arrB = arr.filter(item => item.length >= MAXLENGTHA)

    if (arrA.length) {
      sendData.emit(arrA.flat(Infinity), true)
    }
    if (arrB.length) {
      const arrBsum = []
      arrB.forEach(item => {
        const sumItem = item[0]
        sumItem.batchError = true
        sumItem.batchErrorLength = item.length
        sumItem.batchErrorLastHappenTime = item[item.length - 1].triggerTime
        arrBsum.push(sumItem)
      })
      sendData.emit(arrBsum, true)
    }
  }

  // 强制发送机制
  pushCacheErrorA(errorInfo) {
    this.cacheErrorA.push(errorInfo)
    this.throttleProxyAddCacheErrorA()

    // 每 50 个触发一次强制发送事件
    if (this.cacheErrorA.length >= 50) {
      this.proxyAddCacheErrorA()
      this.proxyAddCacheErrorB()
    }
  }
}
```
### 忽略指定错误
```js
function isIgnoreErrors {
  if (!options.value.ignoreErrors.length) return false
  let errMessage = error.errMessage || error.message
  if (!errMessage) return false
  errMessage = String(errMessage)

  return options.value.ignoreErrors.some(item => {
    if (isRegExp(item)) {
      if ((item as RegExp).test(errMessage)) {
        debug(`ignoreErrors拦截成功 - 截条件:${item} 错误信息:${errMessage}`)
        return true
      } else {
        return false
      }
    } else {
      if (errMessage === item) {
        debug(`ignoreErrors拦截成功 - 截条件:${item} 错误信息:${errMessage}`)
        return true
      } else {
        return false
      }
    }
  })
}
```
### 错误采样
emit函数调用时，可以通过设置采样率防止大量相同错误上报，以减少服务器压力。
```js
function emit() {
  // 命中采样配置，不予上报
  if (!errorSampler.shouldSample(errorInfo)) return;

  const info = {
    ...errorInfo,
    eventType: SEDNEVENTTYPES.ERROR,
    recordscreen: options.value.recordScreen ? zip(getRecordEvent()) : null,
    triggerPageUrl: getLocationHref(),
    triggerTime: getTimestamp()
  }

  options.value.scopeError
    ? batchError.pushCacheErrorA(info)
    : sendData.emit(info, flush)
}
```
```js
class ErrorSampler {
  shouldSample() {
    // 通过这段代码判断
    const shouldSample = Math.random() < this.config.rate;
  }
}
```
### 格式化不同的错误事件
```js
function parseErrorEvent(event: ErrorEvent | PromiseRejectedResult) {
  // promise reject 错误
  if (isPromiseRejectedResult(event)) {
    return { eventId: SENDID.CODE, ...parseError(event.reason) }
  }

  // html元素上发生的异常错误
  const { target } = event
  if (target instanceof HTMLElement) {
    // 为1代表节点是元素节点
    if (target.nodeType === 1) {
      const result = {
        initiatorType: target.nodeName.toLowerCase(),
        eventId: SENDID.RESOURCE,
        requestUrl: ''
      }
      switch (target.nodeName.toLowerCase()) {
        case 'link':
          result.requestUrl = (target as HTMLLinkElement).href
          break
        default:
          result.requestUrl =
            (target as HTMLImageElement).currentSrc ||
            (target as HTMLScriptElement).src
      }
      return result
    }
  }

  // 代码异常
  if (event.error) {
    // chrome中的error对象没有fileName等属性,将event中的补充给error对象
    const e = event.error
    e.fileName = e.filename || event.filename
    e.columnNumber = e.colno || event.colno
    e.lineNumber = e.lineno || event.lineno
    return { eventId: SENDID.CODE, ...parseError(e) }
  }

  // 兜底
  // ie9版本,从全局的event对象中获取错误信息
  return {
    eventId: SENDID.CODE,
    line: (_global as any).event.errorLine,
    col: (_global as any).event.errorCharacter,
    errMessage: (_global as any).event.errorMessage,
    triggerPageUrl: (_global as any).event.errorUrl
  }
}
```
格式化后的错误格式
 Promise {
	eventId: SENDID.CODE,
	errMessage: "Promise rejection reason",
	errStack: "Error stack trace"
 }

资源错误 {
	eventId: SENDID.RESOURCE,
	initiatorType: "img", // 或 "script", "link"
	requestUrl: "https://example.com/image.jpg"
}

代码错误 {
	eventId: SENDID.CODE,
	errMessage: "Error message",
	errStack: "Error stack trace",
	fileName: "file.js",
	lineNumber: 123,
	columnNumber: 45
}
## 监控平台如何录屏
初始化代码
```js
export function initRecordScreen() {
  watch(options, (newValue, oldValue) => {
    if (newValue.recordScreen === oldValue.recordScreen) return

    if (newValue.recordScreen) recordScreen = new RecordScreen()
    else {
      recordScreen?.close()
      recordScreen = undefined
    }
  })

  recordScreen = options.value.recordScreen ? new RecordScreen() : undefined
}
```
initRecordScreen()方法调用了RecordScreen类的init
```js
const MAXSCOPETIME = 5000 // 每5s记录一个区间
const MAXSCOPELENGTH = 3 // 录屏数组最长长度 - 不要小于3

class RecordScreen {
  public eventList: RecordEventScope[] = [{ scope: `${getTimestamp()}-`, eventList: [] }] 
  private closeCallback; // 关闭录制的函数
  private pageStateMonitor: PageStateMonitor; // 监控页面状态，决定以什么方式录制
  
  constructor() {
    // 初始化页面监控
    this.pageStateMonitor = new PageStateMonitor();
    this.initStateListener()
  }

  private initStateListener() {
    // 页面状态更新后的回调
    this.pageStateMonitor.onStateChange((state) => {
      this.updateRecordingConfig(state);
    });
  }

  private updateRecordingConfig(state: PageState) {
    const config = RecordConfig[state];
    
    // 停止当前录制
    if (this.closeCallback) {
      this.closeCallback();
    }

    // 使用新配置开始录制
    this.closeCallback = record({
      emit: (event, isCheckout) => {
        this.handleEvent(event, isCheckout);
      },
      recordCanvas: config.recordCanvas,
      checkoutEveryNms: config.interval,
      // 根据质量设置采样率
      sampling: {
        mousemove: config.quality === 'high' ? 50 : 100,
        mouseInteraction: config.quality === 'high' ? 10 : 50,
        scroll: config.quality === 'high' ? 50 : 100,
        media: config.quality === 'high' ? 800 : 1000,
        canvas: config.quality === 'high' ? 400 : 1000
      }
    });
  }

  private handleEvent(event: any, isCheckout: boolean) {
    const lastEvents = this.eventList[this.eventList.length - 1];
    lastEvents.eventList.push(event);

    if (isCheckout) {
      if (this.eventList.length > 0) {
        this.eventList[this.eventList.length - 1].scope =
          lastEvents.scope + getTimestamp();
      }
      if (this.eventList.length > MAXSCOPELENGTH) {
        this.eventList.shift();
      }
      this.eventList.push({ scope: `${getTimestamp()}-`, eventList: [] });
    }
  }

  public close() {
    this.closeCallback?.()
    this.closeCallback = undefined
  }
}
```
### 录制的时机和时长
一般通过用户在当前页面的状态，选择对应的录制配置录制；用户状态分为四类：`空闲`、`活跃`、`发生错误`、`性能较差`；
```js
// 定义页面状态
enum PageState {
  ACTIVE = 'active',      // 用户活跃
  IDLE = 'idle',         // 用户空闲
  ERROR = 'error',       // 发生错误
  PERFORMANCE = 'performance' // 性能较差
}

const RecordConfig = {
  [PageState.ACTIVE]: {
    interval: 1000,      // 1秒记录一次
    quality: 'high',     // 高质量
    recordCanvas: true   // 记录canvas，因为DOM快照是无法记录Canvas内的变化的。
    // rrweb通过劫持CanvasAPI的方式，对Canvas的变化进行捕获
  },
  [PageState.IDLE]: {
    interval: 5000,      // 5秒记录一次
    quality: 'low',      // 低质量
    recordCanvas: false  // 不记录canvas
  },
  [PageState.ERROR]: {
    interval: 100,       // 0.1秒记录一次
    quality: 'high',     // 高质量
    recordCanvas: true   // 记录canvas
  },
  [PageState.PERFORMANCE]: {
    interval: 2000,      // 2秒记录一次
    quality: 'medium',   // 中等质量
    recordCanvas: false  // 不记录canvas
  }
}
```
定义一个监控页面状态的类，在SDK入口处初始化这个类，实现页面状态的监听和切换。
```js
class PageStateMonitor {
  private currentState: PageState = PageState.ACTIVE;
  private stateChangeCallbacks: ((state: PageState) => void)[] = [];

  constructor() {
    this.initStateListeners();
  }

  private initStateListeners() {
    let idleTimer: NodeJS.Timeout;

	// 用户30秒无操作视为空闲
    const resetIdleTimer = () => {
      clearTimeout(idleTimer);
      this.setState(PageState.ACTIVE);
      idleTimer = setTimeout(() => {
        this.setState(PageState.IDLE);
      }, 30000);
    };

	// 监听用户交互，如果30s未发生下列交互，进入空闲期
    ['mousemove', 'keydown', 'click', 'scroll'].forEach(event => {
      document.addEventListener(event, resetIdleTimer);
    });

	// 监听错误
    window.addEventListener('error', () => {
      this.setState(PageState.ERROR);
    });

	// 监听性能指标
    this.monitorPerformance();
  }

  private monitorPerformance() {
    // 使用 PerformanceObserver 监控性能
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const fps = this.calculateFPS(entries); // requestAnimationFrame简单计算FPS
      
      if (fps < 30) { // FPS低于30认为性能较差
        this.setState(PageState.PERFORMANCE);
      }
    });

	observer.observe({ entryTypes: ['longtask', 'paint'] }); // 监听长任务和绘制事件
  }

  private setState(newState: PageState) {
    if (this.currentState !== newState) {
      this.currentState = newState;
      this.notifyStateChange(newState);
    }
  }

  // 监控状态改变，执行回调
  private notifyStateChange(state: PageState) {
    this.stateChangeCallbacks.forEach(callback => callback(state));
  }

  // 注册监控状态的回调
  public onStateChange(callback: (state: PageState) => void) {
    this.stateChangeCallbacks.push(callback);
  }
}
```
### 内存管理和数据压缩
在发送时，使用zip函数将录制的数据压缩成Base64发送
```js
function emit(errorInfo: any, flush = false): void {
  const info = {
    ...errorInfo,
    eventType: SEDNEVENTTYPES.ERROR,
    triggerPageUrl: getLocationHref(),
    triggerTime: getTimestamp(),
    recordscreen: options.value.recordScreen ? zip(getRecordEvent()) : null, // 压缩发送
  }

  options.value.scopeError
    ? batchError.pushCacheErrorA(info)
    : sendData.emit(info, flush)
}
```
视频解压时注意切片，防止内存溢出
```js
function unzip(b64Data: string) {
  // 1. Base64解码
  const strData = Base64.atob(b64Data)
  
  // 2. 字符串转字符编码数组
  const charData = strData.split('').map(function (x) {
    return x.charCodeAt(0)
  })
  
  // 3. 创建 Uint8Array
  const binData = new Uint8Array(charData)

  // 4. pako解压缩
  const data: any = pako.ungzip(binData)

  // 5. 分片处理大数据，防止内存溢出
  let str = '';
  let i;
  const chunk = 8 * 1024 // 分块大小8KB
  
  for (i = 0; i < data.length / chunk; i++) {
    // String.fromCharCode字符编码转字符串
    str += String.fromCharCode.apply(null, data.slice(i * chunk, (i * 1) * chunk));
  }
  str += String.fromCharCode.apply(null, data.slice(i * chunk))

  // 6. Base64解码
  const unzipStr = Base64.decode(str)
  
  // 7. JSON解析
  let result = ''
  try {
    result = JSON.parse(unzipStr)
  } catch (error: any) {
    if (/Unexpected token o in JSON at position 0/.test(error)) {
      // 如果不是JSON格式，直接返回字符串
      result = unzipStr
    }
  }

  return result
}

/* result为JSON的返回格式 */
[
  {
    type: 'xx',
    timestamp: 'xx',
    data: {
      initialOffset: { left: 0, top: 0 },
      node: {} // 当前页面的DOM节点树
    }
  },
  ...
]
```
### 对性能的影响
监控平台的录屏功能，主要有三大性能问题：`内存占用`、`CPU使用率`、`数据量过大`

对于内存占用，可以通过设置**最大录制片段**和**最大录制区间**来控制录制数据大大小。设置checkoutEveryNms为没5s重新录制快照，并且在每次录制完成时检查录制数组是否超出长度，如果超出，则抛出最老的数据。
```js
this.closeCallback = record({
      emit: (event, isCheckout) => {
        const lastEvents = this.eventList[this.eventList.length - 1]
        lastEvents.eventList.push(event)

        // isCheckout为标识，表示重新制作了快照
        if (isCheckout) {
          // 完成当前片段的录制
          if (this.eventList.length > 0) {
            this.eventList[this.eventList.length - 1].scope =
              lastEvents.scope + getTimestamp()
          }
          // 控制录制片段的数量
          if (this.eventList.length > MAXSCOPELENGTH) {
            this.eventList.shift() // 删除最老的片段
          }
          this.eventList.push({ scope: `${getTimestamp()}-`, eventList: [] })
        }
      },
      recordCanvas: true,
      checkoutEveryNms: MAXSCOPETIME // 每5s重新制作快照
    })
```
对于CPU的占用，通过动态变更采样率来改善。详见[[#录制的时机和时长]]

数据量过大，可以将其分块压缩，详见[[#内存管理和数据压缩]]
## 监控平台处理点击事件
通过clickCollection方法，收集点击事件；
```js
function clickCollection() {
  // 事件总线添加点击事件监听
  eventBus.addEvent({
    type: EVENTTYPES.CLICK,
    callback: (e: MouseEvent) => {
	  // 创建点击上报的信息模版
      const _config = new RequestTemplateClick({
        eventType: SEDNEVENTTYPES.CLICK
      })

	  // 获取被点击的元素到最外层元素组成的数组
      const path: HTMLElement[] = e.composedPath()
        ? (e.composedPath() as HTMLElement[])
        : e.target
        ? getNodePath(e.target as HTMLElement)
        : []

	  // 检查被点击的元素以及其父级元素是否有这些监控属性(从内到外)
      const target = path.find(
        el =>
          el.hasAttribute &&
          (el.hasAttribute('data-warden-container') ||
            el.hasAttribute('data-warden-event-id') ||
            el.hasAttribute('data-warden-title'))
      )
      
      if (!target) return
      
      const { scrollTop, scrollLeft } = document.documentElement // html距离上和左侧的距离(一般都是0)
      const { top, left } = (e.target as HTMLElement).getBoundingClientRect() // 元素距离html的距离
      _config.x = left + scrollLeft
      _config.y = top + scrollTop
      _config.triggerTime = getTimestamp() // 点击时间
      _config.triggerPageUrl = getLocationHref() // 当前页面的url
      _config.title = extractTitleByTarget(target) // 获取title属性
      _config.eventId = extractDataByPath(path) // 提取数据事件ID
      _config.params = extractParamsByPath(path) // 提取数据参数
      _config.elementPath = getNodeXPath(target).slice(-128) // 长度限制128字符
      sendData.emit(_config)
    }
  })
}
```

首先通过创建RequestTemplateClick实例，来配置click上报的基础信息：
```js
class RequestTemplateClick {
  eventId = '' // 事件ID
  eventType = '' // 事件类型
  title = '' // 事件名
  triggerPageUrl = '' // 当前页面URL
  x = -1 // 被点击元素与屏幕左边距离
  y = -1 // 被点击元素与屏幕上边距离
  params = {} // 事件参数
  elementPath = '' // 被点击元素的层级
  triggerTime = -1 // 事件发生时间
  constructor(config = {}) {
    Object.keys(config).forEach(key => {
      if (isValidKey(key, config)) {
        this[key] = config[key] || null
      }
    })
  }
}
```
## 监控平台处理网络请求
### XHR请求
```js
/* RequestTemplate格式
{
  requestUrl: 'http://localhost:6656/getList?test=123',
  requestMethod: 'get',
  requestParams: { test: '123' },
  triggerTime: 1689729859862,
}
*/
function interceptXHR() {
  const _config = new RequestTemplate()

  // 监听 XMLHttpRequest 的 open 方法调用，收集 HTTP 请求的基本信息
  eventBus.addEvent({
    type: EVENTTYPES.XHROPEN,
    callback: (method, url) => {
      _config.requestMethod = String(method).toLocaleLowerCase()
      _config.requestUrl = url
      _config.requestParams = parseGetParams(url)
    }
  })

  eventBus.addEvent({
    type: EVENTTYPES.XHRSEND,
    callback: (that: XMLHttpRequest, body) => {
      on(
        that,
        EVENTTYPES.READYSTATECHANGE,
        function() {
          const { readyState, status, responseURL, statusText } = that
          const responseText = that.responseType === '' || that.responseType === 'text'
            ? that.responseText
            : ''
            
          if (readState === 4) {
            const requestUrl = responseURL || _config.requestUrl
            if (isIgnoreHttp(requestUrl)) return // 配置了忽略该请求，直接return

			// 请求已完成,且响应已就绪
            if (status === 200 || status === 304) {
              // 是否采集接口请求
              if (options.value.performance.server) {
                handleSendPerformance({
	              eventId: SENDID.SERVER,
	              requestUrl,
	              requestMethod: _config.requestMethod,
	              requestType: 'xhr',
	              responseStatus: status,
	              duration: getTimestamp() - _config.triggerTime,
	              params:  _config.requestMethod === 'post' ? body : _config.requestParams
	            })
			  }
            } else if (options.value.error.server) { // 是否采集报错接口数据
              handleSendError({
                eventId: SENDID.SERVER,
                errMessage: statusText || responseText,
                requestUrl,
                requestMethod: _config.requestMethod,
                requestType: 'xhr',
                responseStatus: status,
                params: _config.requestMethod === 'post' ? body : _config.requestParams
              })
            }
          }
        }
      )
      _config.triggerTime = getTimestamp()
    }
  })
}
```
### Fetch请求
```js
function interceptFetch() {
  eventBus.addEvent({
    type: EVENTTYPES.FETCH,
    callback: (
      reqUrl: string,
      _options = {},
      res: Response,
      fetchStart: number
    ) => {
      const { method = 'GET', body } = _options
      const { url, status, statusText } = res
      const requestMethod = String(method).toLocaleLowerCase()

      if (isIgnoreHttp(url)) return

      if (status === 200 || status === 304) {
        if (options.value.performance.server) {
          handleSendPerformance({
            eventId: SENDID.SERVER,
            requestUrl: url,
            duration: getTimestamp() - fetchStart,
            responseStatus: status,
            requestMethod,
            requestType: 'fetch',
            params: method.toUpperCase() === 'POST' ? body : parseGetParams(url)
          })
        }
      } else if (options.value.error.server) {
        handleSendError({
          eventId: SENDID.SERVER,
          errMessage: statusText,
          requestUrl: url,
          responseStatus: status,
          requestMethod,
          requestType: 'fetch',
          params: method.toUpperCase() === 'POST' ? body : parseGetParams(url)
        })
      }
    }
  })
}
```

## 监控平台采集性能数据
入口函数
```js
function initPerformance() {
  if (
    !options.value.performance.firstResource && // 是否采集首次进入页面的数据
    !options.value.performance.core // 是否采集静态资源、接口的相关数据
  )
    return

  // 检查document.readyState属性来判断onload事件是否会被触发
  if (document.readyState === 'complete') {
    // 此时：
    // 1. 页面完全加载完成
    // 2. 所有资源都已加载
    // 3. 相当于 window.onload 已触发，故直接观察
    observeResource()
  } else {
    // 此时：
    // 1. 页面可能还在加载
    // 2. 资源可能还未加载完成
    // 3. 需要等待 load 事件，然后再执行回调观察
    eventBus.addEvent({
      type: EVENTTYPES.LOAD,
      callback: () => {
        observeResource()
      }
    })
  }
}
```
observeResource逻辑
```js
function observeResource() {
  if (supported.performance && options.value.performance.firstResource) {
    observeNavigationTiming()
  }

  if (supported.performance && options.value.performance.core) {
    traceResourcePerformance(_global.performance)

    if (supported.PerformanceObserver) {
      // 监听异步资源加载性能数据 chrome≥52
      const observer = new PerformanceObserver(traceResourcePerformance)
      observer.observe({ entryTypes: ['resource'] })
    } else if (supported.MutationObserver) {
      // 监听资源、DOM更新操作记录 chrome≥26 ie≥11
      observeSourceInsert()
    }
  }
}
```
observeNavigationTiming监听页面性能数据，具体的数值计算，可以参考
![[Pasted image 20240424114625.png]]
```js
function observeNavigationTiming() {
  const times = {}
  const { performance } = _global
  let t = performance.timing

  times.fmp = 0 // 首屏时间 (渲染节点增量最大的时间点)
  if (supported.getEntriesByType) {
    const paintEntries = performance.getEntriesByType('paint')
    if (paintEntries.length) {
      times.fmp = paintEntries[paintEntries.length - 1].startTime
    }

    // 优先使用 navigation v2  https://www.w3.org/TR/navigation-timing-2/
    if (supported.PerformanceNavigationTiming) {
      const nt2Timing = performance.getEntriesByType('navigation')[0]
      if (nt2Timing) t = nt2Timing
    }
  }

  // 从开始发起这个页面的访问开始算起,减去重定向跳转的时间,在performanceV2版本下才进行计算
  // v1版本的fetchStart是时间戳而不是相对于访问起始点的相对时间
  if (times.fmp && supported.PerformanceNavigationTiming) {
    times.fmp -= t.fetchStart
  }

  // 白屏时间 (从请求开始到浏览器开始解析第一批HTML文档字节的时间差)
  // times.fpt = t.responseEnd - t.fetchStart;

  times.tti = t.domInteractive - t.fetchStart // 首次可交互时间

  times.ready = t.domContentLoadedEventEnd - t.fetchStart // HTML加载完成时间

  times.loadon = t.loadEventStart - t.fetchStart // 页面完全加载时间

  times.firstbyte = t.responseStart - t.domainLookupStart // 首包时间

  times.dns = t.domainLookupEnd - t.domainLookupStart // dns查询耗时

  times.appcache = t.domainLookupStart - t.fetchStart // dns缓存时间

  times.tcp = t.connectEnd - t.connectStart // tcp连接耗时

  times.ttfb = t.responseStart - t.requestStart // 请求响应耗时

  times.trans = t.responseEnd - t.responseStart // 内容传输耗时

  times.dom = t.domInteractive - t.responseEnd // dom解析耗时

  times.res = t.loadEventStart - t.domContentLoadedEventEnd // 同步资源加载耗时

  times.ssllink = t.connectEnd - t.secureConnectionStart // SSL安全连接耗时

  times.redirect = t.redirectEnd - t.redirectStart // 重定向时间

  times.unloadTime = t.unloadEventEnd - t.unloadEventStart // 上一个页面的卸载耗时

  const resultInfo = { ...times, triggerPageUrl: getLocationHref() }

  _support.firstScreen = { ...resultInfo }

  sendData.emit(
    normalizeObj({
      ...resultInfo,
      eventType: SEDNEVENTTYPES.PERFORMANCE,
      eventId: SENDID.PAGE
    })
  )
}
```
traceResourcePerformance 关注页面资源加载方面的数据
```js
function traceResourcePerformance(performance: PerformanceObserverEntryList) {
  // 排除xmlhttprequest类型,服务器有响应便会记录,包括404的请求,转由http-request模块负责记录请求数据,区分请求状态
  // 同时也会排除一些其他类型,比如在引入一个script后会触发一次性能监控,它的类型是beacon,这一次的要排除
  const observerTypeList = ['img', 'script', 'link', 'audio', 'video', 'css']

  const entries = performance.getEntriesByType('resource')
  const records = []

  entries.forEach(entry => {
    // initiatorType含义：通过某种方式请求的资源,例如script,link..
    const { initiatorType = '' } = entry

    // 只记录observerTypeList中列出的资源类型请求,不在列表中则跳过
    if (observerTypeList.indexOf(initiatorType.toLowerCase()) < 0) return

    // sdk内部 img 发送请求的错误不会记录
    if (sendReaconImageList.length) {
      const index = sendReaconImageList.findIndex(
        item => item.src === entry.name
      )

      if (index !== -1) {
        sendReaconImageList.splice(index, 1)
        return
      }
    }

    const value = {}
    Object.keys(performanceEntryAttrs).forEach(attr => {
      if (isValidKey(attr, entry)) {
        value[attr] = entry[attr]
      }
    })

    records.push(
      normalizeObj({
        ...value,
        eventType: SEDNEVENTTYPES.PERFORMANCE,
        eventId: SENDID.RESOURCE,
        requestUrl: entry.name,
        triggerTime: getTimestamp(),
        triggerPageUrl: getLocationHref()
      })
    )
  })

  if (records.length) sendData.emit(records)
  return records
}
```
observeSourceInsert 监听异步插入的script、link、img, DOM更新
```js
function observeSourceInsert() {
  const tags = ['img', 'script', 'link']
  // 检测异步插入的script、link、img,会有一些延迟,一些连接建立、包体大小的数据会丢失,精度下降
  // MutationObserver DOM3 Events规范,是个异步监听,只有在全部DOM操作完成之后才会调用callback
  const observer = new MutationObserver(mutationsList => {
    for (let i = 0; i < mutationsList.length; i += 1) {
      const startTime = getTimestamp()
      const { addedNodes = [] } = mutationsList[i]
      addedNodes.forEach((node: Node & { src?: string; href?: string }) => {
        const { nodeName } = node
        if (tags.indexOf(nodeName.toLowerCase()) !== -1) {
        
          // 资源加载
          on(node as Document, EVENTTYPES.LOAD, function () {
            sendData.emit(
              normalizeObj({
                eventType: SEDNEVENTTYPES.PERFORMANCE,
                eventId: SENDID.RESOURCE,
                requestUrl: node.src || node.href,
                duration: getTimestamp() - startTime,
                triggerTime: getTimestamp(),
                triggerPageUrl: getLocationHref()
              })
            )
          })
          
          // 资源加载错误
          on(node as Document, EVENTTYPES.ERROR, function () {
            sendData.emit(
              normalizeObj({
                eventType: SEDNEVENTTYPES.PERFORMANCE,
                eventId: SENDID.RESOURCE,
                requestUrl: node.src || node.href,
                responseStatus: 'error',
                duration: getTimestamp() - startTime,
                triggerTime: getTimestamp(),
                triggerPageUrl: getLocationHref()
              })
            )
          })
        }
      })
    }
  })
  observer.observe(_global.document, {
    subtree: true, // 目标以及目标的后代改变都会观察
    childList: true // 表示观察目标子节点的变化，比如添加或者删除目标子节点，不包括修改子节点以及子节点后代的变化
    // attributes: true, // 观察属性变动
    // attributeFilter: ['src', 'href'] // 要观察的属性
  })
  // observer.disconnect()
}
```
## 监控平台采集路由PV
采集页面跳转的数据,主要原理是劫持`history.pushState` `history.replaceState`,以及监听`popstate` `hashchange`这两个事件
> 关于单页面与多页面，详见[[1- JS基础#单页面与多页面应用 | 单页面与多页面应用]]

| 属性名称           | 值                                           | 说明      |
| -------------- | ------------------------------------------- | ------- |
| eventId        | 根据时间戳计算得来的字符 (固定为pageId)                    | 事件ID    |
| eventType      | pv                                          | 事件类型    |
| triggerPageUrl |                                             | 当前页面URL |
| referer        |                                             | 上级页面URL |
| title          | document.title                              | 页面标题    |
| sendTime       |                                             | 发送时间    |
| triggerTime    |                                             | 事件发生时间  |
| action         | navigate / reload / back_forward / reserved | 页面加载来源  |
```js
let durationStartTime = getTimestamp()
let lastSendObj = {}

function initPv() {
  if (!options.value.pv.core) return;

  let lastIsPop = false // 最后一次触发路由变化是否为popState触发
  let repetitionRoute = false // 在触发 replaceState 后 100ms 内的 pushState 会被无效记录

  // document.referer 只读属性，存储当前页面的来源页面
  // 从cocument.referer 来到 window.location.href(当前页面)
  sendPageView({ referer: document.referrer }) // 首次进入记录url变化

  eventBus.addEvent({
    type: EVENTTYPES.HISTORYPUSHSTATE, // 监听history.pushState方法调用
    callback: () => {
      if (repetitionRoute) return
      lastIsPop = false
      sendPageView({ action: 'navigation' })
    }
  })

  eventBus.addEvent({
    type: EVENTTYPES.HISTORYREPLACESTATE, // 监听history.replaceState方法调用
    callback: () => {
      repetitionRoute = true
      lastIsPop = false
      sendPageView({ action: 'navigation' })
      // 100ms之后重置标记，因为刷新页面也会导致replaceState，防止短时间内重复记录
      setTimeout(() => {
        repetitionRoute = false
      }, 100)
    }
  })

  eventBus.addEvent({
    type: EVENTTYPES.HASHCHANGE, // 监听hashChange方法调用
    callback: () => {
      if (repetitionRoute) return
      if (!lastIsPop) sendPageView()
      lastIsPop = false
    }
  })

  eventBus.addEvent({
    type: EVENTTYPES.POPSTATE, // 点击浏览器后退按钮 or 调用history.back触发
    callback: () => {
      if (repetitionRoute) return
      
      // 如果页面只有hash值改变不记录新的PV
      if (_global.location.hash !== '') { // 存在hash值
        // 判断旧URL中是否含有‘#’，含有取前半部分，不含有使用整个URL
        const oldHost =
          oldURL.indexOf('#') > 0
            ? oldURL.slice(0, oldURL.indexOf('#'))
            : oldURL
        // 如果新旧URL的非hash部分相同，直接返回，不记录新的PV
        if (
          _global.location.href.slice(0, _global.location.href.indexOf('#')) ===
          oldHost
        )
          return
      }
      
      lastIsPop = true // 标记为pop操作
      sendPageView()
    }
  })

  // 在页面卸载时，发送页面停留时间信息
  eventBus.addEvent({
    type: EVENTTYPES.BEFOREUNLOAD,
    callback: () => {
      const durationTime = getTimestamp() - durationStartTime
      if (Object.values(lastSendObj).length > 0 && durationTime > 100) {
        sendData.emit({ ...lastSendObj, durationTime }, true) // true => 立即发送
      }
    }
  })
}
```
sendPageView方法详解
```js
export const WEBPAGELOAD: Record<number, string> = {
  0: 'navigate', // 网页通过点击链接,地址栏输入,表单提交,脚本操作等方式加载
  1: 'reload', // 网页通过“重新加载”按钮或者location.reload()方法加载
  2: 'back_forward', // 网页通过“前进”或“后退”按钮加载
  255: 'reserved' // 任何其他来源的加载
}
function sendPageView() {
  const { referer = oldURL, action, params, title } = option
  let _action = action
  if (!_action) {
    _action = WEBPAGELOAD[performance.navigation.type] || ''
  }

  // ------------- 发送路由跳转时间事件 -------------
  // 如果option.title为空,则等待框架处理document.title,延迟17ms
  // 为什么是17ms?  一秒60Hz是基准,平均1Hz是17毫秒,只要出来了页面那就有 document.title
  setTimeout(
    () => {
      oldURL = getLocationHref()
      const sendObj = {
        eventType: SEDNEVENTTYPES.PV,
        eventId: baseInfo.pageId,
        triggerPageUrl: getLocationHref(),
        referer,
        params,
        title: title || document.title,
        action: _action,
        triggerTime: getTimestamp()
      }
      sendData.emit(sendObj)

      // ------------- 发送上一个页面停留时间事件 -------------
      const durationTime = getTimestamp() - durationStartTime
      durationStartTime = getTimestamp()
      if (Object.values(lastSendObj).length > 0 && durationTime > 100) {
        sendData.emit({ ...lastSendObj, durationTime })
      }
      lastSendObj = {
        ...sendObj,
        eventType: SEDNEVENTTYPES.PVDURATION
      }
    },
    title ? 0 : 17
  )
}
```
## 监控平台监听元素曝光
```js
class Intersection {
  private ioMap: IoMap = {}
  private targetMap: TargetMap[] = []
  private options = {
    root: null,
    rootMargin: '0px',
    threshold: 0.5 // 阀值设为0.5，当只有比例达到一半时才触发回调函数
  }
}
```