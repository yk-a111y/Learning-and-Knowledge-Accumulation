![[Pasted image 20250107150942.png]]
## 监控的初始化
### 重写浏览器事件
监控平台一般需要对一些浏览器原生事件重写，这样做的原因是因为：监控代码需要与业务代码`解耦`，故将事件的监控逻辑放在事件捕获阶段执行，这样即可保证对`业务代码零侵入` & `监控全面性`

具体代码，分为监听和重写两种，有些时间只关心`事件`发生时机，那么监听即可；针对需要在某些`方法`执行前后做事情的情况，需要重写。
```ts
// 定义通用的事件注册逻辑
function on (target: Window | Document, eventName: string, handler: Function, options = false) {
	target.addEventListener(eventName, handler, options);
}

/* 
	原生事件的监听，除error和unhandledrejection外，还有：
		click -- 加节流监听，避免上报过多数据
		load -- 整个页面及所有依赖资源都加载完成时触发
		beforeunload -- 用户准备离开页面时触发，页面生命周期的最后一个可捕获的时机
		hashchange -- 监听hash模式下路由的变化
		popstate -- 监听History模式下页面的前进/后退
		offline & online -- 监听网络开启 & 关闭
*/
function listenerError (type) {
	// 监听error事件，并使用eventBus发送事件, true代表在事件捕获阶段执行
	on(_global, 'error', function(e: ErrorEvent){ eventBus.runEvent(type, e) }, true)
}

function listenUnhandledrejection (type) {
	// 监听Promise异常，并使用eventBus发送事件
	on(_global, 'unhandledrejection', function(ev: PromiseRejectionEvent){ eventBus.runEvent(type, ev) }, true)
}


/* 
	原生事件的重写，除了console.error外，还有：
		XMLHttpRequest.open -- XMLHTTPRequest打开时，能收集到请求的配置信息
		XMLHttpRequest.send -- XMLHTTPRequest发送时，收集请求体和 XHR 实例
		fetch -- fetch请求方法
		replaceState -- 添加新的历史记录
		pushState -- 替换当前历史记录
*/
function replaceConsoleError (type) {
	// 重写console.error方法
	replaceAop(console, 'error', (originalFn) => {
		return function(this, ...args) {
			// 避免监控系统自身的错误日志造成死循环
			if (
				!(args[0] && args[0].slice && args[0].slice(0, 12) === '@web-tracing')
			) {
				eventBus.runEvent(type, args)
			}
			// 调用原方法，即console.error本体
			originalError.apply(this, args)
		}
	})
}

/**
 * 重写对象上面的某个属性
 * @param source 需要被重写的对象
 * @param name 需要被重写对象的key
 * @param replacement 以原有的函数作为参数，执行并重写原有函数
 * @param isForced 是否强制重写（可能原先没有该属性）
 */
function replaceAop(source, name, replacement, isForced = false) {
	if (source === undefined) return;
	
	if (name in source || isForced) {
		const original = source[name];
		const wrapped = replacement(original);
		
		if (isFunction(wrapped)) {
	      source[name] = wrapped
	    }
	}
}
```

### 初始化设备信息
通过初始化baseInfo类，创建设备的基础信息和Base数据，代码如下：
```js
class BaseInfo {
	public base;
	public pageId;
	private sdkUserUuid = '';
	private device;
	// 基础信息是否初始化成功
	public _initSuccess = false
	
	constructor() {
		this.pageId = uuid();// 当前应用ID，在整个页面生命周期内不变，单页应用路由变化也不会改变；加载SDK时创建且只创建一次
		
		this.initSdkUserUuid()
			.then(
				this.initDevice();
		        this.initBase();
			)
			.finally(
				this._initSuccess = true
			    sendData.emit([])
			)
	}

	private initSdkUserUuid() {
		return isTestEnv
			? Promise.resolve().then(() => {
				this.sdkUserUuid = '_unit-test-id'
				options.value.sdkUserUuid = '_unit-test-id'
			  })
			: load({})
				.then((fp: any) => fp.get()) // load为获取设备指纹的方法，用户未登录的情况下最大限度标明用户唯一身份
				.then((result) => {
					const visitorId = result.visitorId;
					this.sdkUserUuid = visitorId;
					options.value.sdkUserUuid = visitorId;
				})
	}

	private initDevice() {
		const { screen } = getGlobal() // getGlobal => 获取当前环境的全局变量
	    const { clientWidth, clientHeight } = document.documentElement
	    const { width, height, colorDepth, pixelDepth } = screen
	    let deviceId = getCookieByName(DEVICE_KEY)
	    if (!deviceId) {
	      deviceId = `t_${uuid()}`
	      document.cookie = `${DEVICE_KEY}=${deviceId};path=/;`
	    }

		this.device = {
		  deviceId, // id
	      clientHeight, // 网页可见区高度
	      clientWidth, // 网页可见区宽度
	      colorDepth, // 显示屏幕调色板的比特深度
	      pixelDepth, // 显示屏幕的颜色分辨率
	      screenWidth: width, // 显示屏幕的宽度
	      screenHeight: height, // 显示屏幕的高度
	      vendor: navigator.vendor, // 浏览器名称
	      platform: navigator.platform // 浏览器平台的环境,不是电脑系统的x64这样的(浏览器平台的环境可能是x32)
	    }
	}

	private initBase() {
		// 与一般业务上理解的sessionId做区分,此session与业务无关,单纯就是浏览器端和后端直接的联系
		const sessionId = getSessionId();
		let ip = '';

		this.base = computed(() => ({
	      ...this.device!,
	      userUuid: options.value.userUuid,
	      ext: options.value.ext,
	      appName: options.value.appName,
	      appCode: options.value.appCode,
	      sdkUserUuid: this.sdkUserUuid,
	      pageId: this.pageId,
	      sdkVersion: SDK_VERSION,
	      sessionId,
	      ip
	    }))
	}
}
```

### 向服务端发送数据
```js
class SendData {
  private events = [] // 批次队列
  private timeoutID: NodeJS.Timeout | undefined // 延迟发送ID

  private send() {
    if (!this.events.length) return;
    
    // 选取首部的部分数据来发送,performance会一次性采集大量数据追加到events中
    const sendEvents = this.events.slice(0, options.value.cacheMaxLength) // 需要发送的事件
	this.events = this.events.slice(options.value.cacheMaxLength) // 剩下待发的事件

	// 构建发送参数
	const time = getTimestamp();
	const sendParams = computed(() => {
	  baseInfo: {
	    ...baseInfo.base?.value,
	    sendTime: time,
	    userUuid: options.value.userUuid
	  },
	  eventInfo: map(sendEvents, (e: any) => {
        e.sendTime = time
        return e
      })
	})

	// 本地化拦截, 如果开启了本地化存储，将数据存储到 localStorage
	if (options.value.localization) {
	  const success = LocalStorageUtil.setSendDataItem(
        SDK_LOCAL_KEY,
        sendParams.value
      );
      
	  // 如果存储失败，触发溢出回调
	  if (!success) options.value.localizationOverFlow(sendParams.value)
      return
	}

	// 经过前置钩子处理的最终数据
    const afterSendParams = executeFunctions(
      options.value.beforeSendData,
      false,
      sendParams.value
    )
    if (isFlase(afterSendParams)) return
    if (!this.validateObject(afterSendParams, 'beforeSendData')) return

	debug('send events', sendParams.value);

	this.executeSend(options.value.dsn, afterSendParams).then((res: any) => {
	  // 执行所有「发送后」Hook
      executeFunctions(options.value.afterSendData, true, {
        ...res,
        params: afterSendParams
      })
    })

	// 如果一次性发生的事件超过了阈值(cacheMaxLength)，那么这些经过裁剪的事件列表剩下的会直接发，并不会延迟等到下一个队列
	if (this.events.length) {
      nextTime(this.send.bind(this)) // 继续传输剩余内容,在下一个时间择机传输
    }
  }

  private executeSend(url: string, data) {
    let sendType = 1;
    if (options.value.sendTypeByXmlBody) {
      // 强制指定 xml body 形式
      sendType = 3
    } else if (_global.navigator) {
      // sendBeacon 最大64kb
      sendType = isObjectOverSizeLimit(data, 60) ? 3 : 1
    } else {
      // img 限制在 2kb
      sendType = isObjectOverSizeLimit(data, 2) ? 3 : 2
    }

	return new Promise(resolve => {
      switch (sendType) {
        case 1:
          resolve({ sendType: 'sendBeacon', success: sendByBeacon(url, data) })
          break
        case 2:
          sendByImage(url, data).then(() => {
            resolve({ sendType: 'image', success: true })
          })
          break
        case 3:
          sendByXML(url, data).then(() => {
            resolve({ sendType: 'xml', success: true })
          })
          break
      }
    })
  }
}

// 选取执行发送代码的理想时间
const nextTime =
  window.requestIdleCallback ||
  window.requestAnimationFrame ||
  (callback => setTimeout(callback, 17))
```

发送数据的三种方式
详细描述见：[[2 - 数据结构设计#监控上报时机|监控上报时机]]

sendBeacon
```js
export function sendByBeacon(url: string, data: any) {
  return navigator.sendBeacon(url, JSON.stringify(data))
}
```

Img
```js
export const sendReaconImageList = []

export function sendByImage(url: string, data: any): Promise<void> {
  return new Promise(resolve => {
    const beacon = new Image()
    beacon.src = `${url}?v=${encodeURIComponent(JSON.stringify(data))}`
    sendReaconImageList.push(beacon)
    beacon.onload = () => {
      // 发送成功
      resolve()
    }
    beacon.onerror = function () {
      // 发送失败
      resolve()
    }
  })
}
```
XML
```js
export function sendByXML(url: string, data: any): Promise<void> {
  return new Promise(resolve => {
    const xhr = new XMLHttpRequest()
    xhr.open('post', url)
    xhr.setRequestHeader('content-type', 'application/json')
    xhr.send(JSON.stringify(data))
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        resolve()
      }
    }
  })
}
```
### 网络监听
当处于断网状态下的所有埋点事件都无效（认为此时采集的数据大部分是无效的）
```js
class LineStatus {
  onLine = true
  
  constructor() {
    this.init()
  }

  init() {
	eventBus.addEvent({
      type: EVENTTYPES.OFFLINE,
      callback: e => {
        if (e.type === 'offline') {
          debug('网络断开')
          this.onLine = false
        }
      }
    });
    
    eventBus.addEvent({
      type: EVENTTYPES.ONLINE,
      callback: e => {
        if (e.type === 'online') {
          debug('网络连接')
          this.onLine = true
        }
      }
    })
  }
}
```

## 监控平台处理错误
核心逻辑
```js
function initError() {
  if (!options.value.error.core) return // 1. 为启用错误监控

  // 2. 批量处理错误：script.onError link.onError img.onError
  if (options.value.scopeError) {
    initBatchError()
    // 页面卸载前发送缓存的错误 以防缓存池内的错误丢失
    eventBus.addEvent({
      type: EVENTTYPES.BEFOREUNLOAD,
      callback: () => {
        batchError.sendAllCacheError()
      }
    })
  }

  // 3. 资源加载错误监控：reject处理过的错误不进行捕获
  eventBus.addEvent({
    type: EVENTTYPES.ERROR,
    callback: (e: ErrorEvent) => {
      const errorInfo = parseErrorEvent(e)
      if (isIgnoreErrors(errorInfo)) return // 如果是忽略的错误，不上报
      emit(errorInfo)
    }
  })

  // 4. Promise 未捕获异常监控
  eventBus.addEvent({
    type: EVENTTYPES.UNHANDLEDREJECTION,
    callback: (e: PromiseRejectedResult) => {
      const errorInfo = parseErrorEvent(e)
      if (isIgnoreErrors(errorInfo)) return
      emit(errorInfo)
    }
  })

  // 5. console.error 监控
  eventBus.addEvent({
    type: EVENTTYPES.CONSOLEERROR,
    callback: e => {
      const errorInfo = parseError(e)
      if (isIgnoreErrors(errorInfo)) return
      emit({ eventId: SENDID.CODE, ...errorInfo })
    }
  })
}
```
## 监控平台如何录屏
初始化代码
```js
export function initRecordScreen() {
  watch(options, (newValue, oldValue) => {
    if (newValue.recordScreen === oldValue.recordScreen) return

    if (newValue.recordScreen) recordScreen = new RecordScreen()
    else {
      recordScreen?.close()
      recordScreen = undefined
    }
  })

  recordScreen = options.value.recordScreen ? new RecordScreen() : undefined
}
```
initRecordScreen()方法调用了RecordScreen类的init
```js
const MAXSCOPETIME = 5000 // 每5s记录一个区间
const MAXSCOPELENGTH = 3 // 录屏数组最长长度 - 不要小于3

class RecordScreen {
  public eventList: RecordEventScope[] = [{ scope: `${getTimestamp()}-`, eventList: [] }] 
  private closeCallback; // 关闭录制的函数
  private pageStateMonitor: PageStateMonitor; // 监控页面状态，决定以什么方式录制
  
  constructor() {
    // 初始化页面监控
    this.pageStateMonitor = new PageStateMonitor();
    this.initStateListener()
  }

  private initStateListener() {
    // 页面状态更新后的回调
    this.pageStateMonitor.onStateChange((state) => {
      this.updateRecordingConfig(state);
    });
  }

  private updateRecordingConfig(state: PageState) {
    const config = RecordConfig[state];
    
    // 停止当前录制
    if (this.closeCallback) {
      this.closeCallback();
    }

    // 使用新配置开始录制
    this.closeCallback = record({
      emit: (event, isCheckout) => {
        this.handleEvent(event, isCheckout);
      },
      recordCanvas: config.recordCanvas,
      checkoutEveryNms: config.interval,
      // 根据质量设置采样率
      sampling: {
        mousemove: config.quality === 'high' ? 50 : 100,
        mouseInteraction: config.quality === 'high' ? 10 : 50,
        scroll: config.quality === 'high' ? 50 : 100,
        media: config.quality === 'high' ? 800 : 1000,
        canvas: config.quality === 'high' ? 400 : 1000
      }
    });
  }

  private handleEvent(event: any, isCheckout: boolean) {
    const lastEvents = this.eventList[this.eventList.length - 1];
    lastEvents.eventList.push(event);

    if (isCheckout) {
      if (this.eventList.length > 0) {
        this.eventList[this.eventList.length - 1].scope =
          lastEvents.scope + getTimestamp();
      }
      if (this.eventList.length > MAXSCOPELENGTH) {
        this.eventList.shift();
      }
      this.eventList.push({ scope: `${getTimestamp()}-`, eventList: [] });
    }
  }

  public close() {
    this.closeCallback?.()
    this.closeCallback = undefined
  }
}
```
### 录制的时机和时长
一般通过用户在当前页面的状态，选择对应的录制配置录制；用户状态分为四类：`空闲`、`活跃`、`发生错误`、`性能较差`；
```js
// 定义页面状态
enum PageState {
  ACTIVE = 'active',      // 用户活跃
  IDLE = 'idle',         // 用户空闲
  ERROR = 'error',       // 发生错误
  PERFORMANCE = 'performance' // 性能较差
}

const RecordConfig = {
  [PageState.ACTIVE]: {
    interval: 1000,      // 1秒记录一次
    quality: 'high',     // 高质量
    recordCanvas: true   // 记录canvas
  },
  [PageState.IDLE]: {
    interval: 5000,      // 5秒记录一次
    quality: 'low',      // 低质量
    recordCanvas: false  // 不记录canvas
  },
  [PageState.ERROR]: {
    interval: 500,       // 0.5秒记录一次
    quality: 'high',     // 高质量
    recordCanvas: true   // 记录canvas
  },
  [PageState.PERFORMANCE]: {
    interval: 2000,      // 2秒记录一次
    quality: 'medium',   // 中等质量
    recordCanvas: false  // 不记录canvas
  }
}
```
定义一个监控页面状态的类，在SDK入口处初始化这个类，实现页面状态的监听和切换。
```js
class PageStateMonitor {
  private currentState: PageState = PageState.ACTIVE;
  private stateChangeCallbacks: ((state: PageState) => void)[] = [];

  constructor() {
    this.initStateListeners();
  }

  private initStateListeners() {
    let idleTimer: NodeJS.Timeout;

	// 用户30秒无操作视为空闲
    const resetIdleTimer = () => {
      clearTimeout(idleTimer);
      this.setState(PageState.ACTIVE);
      idleTimer = setTimeout(() => {
        this.setState(PageState.IDLE);
      }, 30000);
    };

	// 监听用户交互，如果30s未发生下列交互，进入空闲期
    ['mousemove', 'keydown', 'click', 'scroll'].forEach(event => {
      document.addEventListener(event, resetIdleTimer);
    });

	// 监听性能指标
    this.monitorPerformance();

	// 监听错误
    window.addEventListener('error', () => {
      this.setState(PageState.ERROR);
    });
  }

  private monitorPerformance() {
    // 使用 PerformanceObserver 监控性能
    const observer = new PerformanceObserver((list) => {
      const entries = list.getEntries();
      const fps = this.calculateFPS(entries);
      
      if (fps < 30) { // FPS低于30认为性能较差
        this.setState(PageState.PERFORMANCE);
      }
    });

	observer.observe({ entryTypes: ['longtask', 'paint'] });
  }

  private setState(newState: PageState) {
    if (this.currentState !== newState) {
      this.currentState = newState;
      this.notifyStateChange(newState);
    }
  }

  // 监控状态改变，执行回调
  private notifyStateChange(state: PageState) {
    this.stateChangeCallbacks.forEach(callback => callback(state));
  }

  // 注册监控状态的回调
  public onStateChange(callback: (state: PageState) => void) {
    this.stateChangeCallbacks.push(callback);
  }
}
```
### 内存管理和数据压缩
在发送时，使用zip函数将录制的数据压缩成Base64发送
```js
function emit(errorInfo: any, flush = false): void {
  const info = {
    ...errorInfo,
    eventType: SEDNEVENTTYPES.ERROR,
    triggerPageUrl: getLocationHref(),
    triggerTime: getTimestamp(),
    recordscreen: options.value.recordScreen ? zip(getRecordEvent()) : null, // 压缩发送
  }

  options.value.scopeError
    ? batchError.pushCacheErrorA(info)
    : sendData.emit(info, flush)
}
```
视频解压时注意切片，防止内存溢出
```js
function unzip(b64Data: string) {
  // 1. Base64解码
  const strData = Base64.atob(b64Data)
  
  // 2. 字符串转字符编码数组
  const charData = strData.split('').map(function (x) {
    return x.charCodeAt(0)
  })
  
  // 3. 创建 Uint8Array
  const binData = new Uint8Array(charData)

  // 4. pako解压缩
  const data: any = pako.ungzip(binData)

  // 5. 分片处理大数据，防止内存溢出
  let str = '';
  let i;
  const chunk = 8 * 1024 // 分块大小8KB
  
  for (i = 0; i < data.length / chunk; i++) {
    // String.fromCharCode字符编码转字符串
    str += String.fromCharCode.apply(null, data.slice(i * chunk, (i * 1) * chunk));
  }
  str += String.fromCharCode.apply(null, data.slice(i * chunk))

  // 6. Base64解码
  const unzipStr = Base64.decode(str)
  
  // 7. JSON解析
  let result = ''
  try {
    result = JSON.parse(unzipStr)
  } catch (error: any) {
    if (/Unexpected token o in JSON at position 0/.test(error)) {
      // 如果不是JSON格式，直接返回字符串
      result = unzipStr
    }
  }

  return result
}

/* result为JSON的返回格式 */
[
  {
    type: 'xx',
    timestamp: 'xx',
    data: {
      initialOffset: { left: 0, top: 0 },
      node: {} // 当前页面的DOM节点树
    }
  },
  ...
]
```
### 对性能的影响
监控平台的录屏功能，主要有三大性能问题：`内存占用`、`CPU使用率`、`数据量过大`

对于内存占用，可以通过设置**最大录制片段**和**最大录制区间**来控制录制数据大大小。设置checkoutEveryNms为没5s重新录制快照，并且在每次录制完成时检查录制数组是否超出长度，如果超出，则抛出最老的数据。
```js
this.closeCallback = record({
      emit: (event, isCheckout) => {
        const lastEvents = this.eventList[this.eventList.length - 1]
        lastEvents.eventList.push(event)

        // isCheckout为标识，表示重新制作了快照
        if (isCheckout) {
          // 完成当前片段的录制
          if (this.eventList.length > 0) {
            this.eventList[this.eventList.length - 1].scope =
              lastEvents.scope + getTimestamp()
          }
          // 控制录制片段的数量
          if (this.eventList.length > MAXSCOPELENGTH) {
            this.eventList.shift() // 删除最老的片段
          }
          this.eventList.push({ scope: `${getTimestamp()}-`, eventList: [] })
        }
      },
      recordCanvas: true,
      checkoutEveryNms: MAXSCOPETIME // 每5s重新制作快照
    })
```
对于CPU的占用，通过动态变更采样率来改善。详见[[#录制的时机和时长]]

数据量过大，可以将其分块压缩，详见[[#内存管理和数据压缩]]