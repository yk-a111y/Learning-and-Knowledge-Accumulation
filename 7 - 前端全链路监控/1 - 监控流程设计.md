![[Pasted image 20250107150942.png]]
## 监控的初始化
### 重写浏览器事件
监控平台一般需要对一些浏览器原生事件重写，这样做的原因是因为：监控代码需要与业务代码`解耦`，故将事件的监控逻辑放在事件捕获阶段执行，这样即可保证对`业务代码零侵入` & `监控全面性`

具体代码，分为监听和重写两种，有些时间只关心`事件`发生时机，那么监听即可；针对需要在某些`方法`执行前后做事情的情况，需要重写。
```ts
// 定义通用的事件注册逻辑
function on (target: Window | Document, eventName: string, handler: Function, options = false) {
	target.addEventListener(eventName, handler, options);
}

/* 
	原生事件的监听，除error和unhandledrejection外，还有：
		click -- 加节流监听，避免上报过多数据
		load -- 整个页面及所有依赖资源都加载完成时触发
		beforeunload -- 用户准备离开页面时触发，页面生命周期的最后一个可捕获的时机
		hashchange -- 监听hash模式下路由的变化
		popstate -- 监听History模式下页面的前进/后退
		offline & online -- 监听网络开启 & 关闭
*/
function listenerError (type) {
	// 监听error事件，并使用eventBus发送事件, true代表在事件捕获阶段执行
	on(_global, 'error', function(e: ErrorEvent){ eventBus.runEvent(type, e) }, true)
}

function listenUnhandledrejection (type) {
	// 监听Promise异常，并使用eventBus发送事件
	on(_global, 'unhandledrejection', function(ev: PromiseRejectionEvent){ eventBus.runEvent(type, ev) }, true)
}


/* 
	原生事件的重写，除了console.error外，还有：
		XMLHttpRequest.open -- XMLHTTPRequest打开时，能收集到请求的配置信息
		XMLHttpRequest.send -- XMLHTTPRequest发送时，收集请求体和 XHR 实例
		fetch -- fetch请求方法
		replaceState -- 添加新的历史记录
		pushState -- 替换当前历史记录
*/
function replaceConsoleError (type) {
	// 重写console.error方法
	replaceAop(console, 'error', (originalFn) => {
		return function(this, ...args) {
			// 避免监控系统自身的错误日志造成死循环
			if (
				!(args[0] && args[0].slice && args[0].slice(0, 12) === '@web-tracing')
			) {
				eventBus.runEvent(type, args)
			}
			// 调用原方法，即console.error本体
			originalError.apply(this, args)
		}
	})
}

/**
 * 重写对象上面的某个属性
 * @param source 需要被重写的对象
 * @param name 需要被重写对象的key
 * @param replacement 以原有的函数作为参数，执行并重写原有函数
 * @param isForced 是否强制重写（可能原先没有该属性）
 */
function replaceAop(source, name, replacement, isForced = false) {
	if (source === undefined) return;
	
	if (name in source || isForced) {
		const original = source[name];
		const wrapped = replacement(original);
		
		if (isFunction(wrapped)) {
	      source[name] = wrapped
	    }
	}
}
```

### 初始化设备信息
通过初始化baseInfo类，创建设备的基础信息和Base数据，代码如下：
```js
class BaseInfo {
	public base;
	public pageId;
	private sdkUserUuid = '';
	private device;
	// 基础信息是否初始化成功
	public _initSuccess = false
	
	constructor() {
		this.pageId = uuid();// 当前应用ID，在整个页面生命周期内不变，单页应用路由变化也不会改变；加载SDK时创建且只创建一次
		
		this.initSdkUserUuid()
			.then(
				this.initDevice();
		        this.initBase();
			)
			.finally(
				this._initSuccess = true
			    sendData.emit([])
			)
	}

	private initSdkUserUuid() {
		return isTestEnv
			? Promise.resolve().then(() => {
				this.sdkUserUuid = '_unit-test-id'
				options.value.sdkUserUuid = '_unit-test-id'
			  })
			: load({})
				.then((fp: any) => fp.get()) // load为获取设备指纹的方法，用户未登录的情况下最大限度标明用户唯一身份
				.then((result) => {
					const visitorId = result.visitorId;
					this.sdkUserUuid = visitorId;
					options.value.sdkUserUuid = visitorId;
				})
	}

	private initDevice() {
		const { screen } = getGlobal() // getGlobal => 获取当前环境的全局变量
	    const { clientWidth, clientHeight } = document.documentElement
	    const { width, height, colorDepth, pixelDepth } = screen
	    let deviceId = getCookieByName(DEVICE_KEY)
	    if (!deviceId) {
	      deviceId = `t_${uuid()}`
	      document.cookie = `${DEVICE_KEY}=${deviceId};path=/;`
	    }

		this.device = {
		  deviceId, // id
	      clientHeight, // 网页可见区高度
	      clientWidth, // 网页可见区宽度
	      colorDepth, // 显示屏幕调色板的比特深度
	      pixelDepth, // 显示屏幕的颜色分辨率
	      screenWidth: width, // 显示屏幕的宽度
	      screenHeight: height, // 显示屏幕的高度
	      vendor: navigator.vendor, // 浏览器名称
	      platform: navigator.platform // 浏览器平台的环境,不是电脑系统的x64这样的(浏览器平台的环境可能是x32)
	    }
	}

	private initBase() {
		// 与一般业务上理解的sessionId做区分,此session与业务无关,单纯就是浏览器端和后端直接的联系
		const sessionId = getSessionId();
		let ip = '';

		this.base = computed(() => ({
	      ...this.device!,
	      userUuid: options.value.userUuid,
	      ext: options.value.ext,
	      appName: options.value.appName,
	      appCode: options.value.appCode,
	      sdkUserUuid: this.sdkUserUuid,
	      pageId: this.pageId,
	      sdkVersion: SDK_VERSION,
	      sessionId,
	      ip
	    }))
	}
}
```

### 向服务端发送数据
```js
class SendData {
  private events = [] // 批次队列
  private timeoutID: NodeJS.Timeout | undefined // 延迟发送ID

  private send() {
    if (!this.events.length) return;
    
    // 选取首部的部分数据来发送,performance会一次性采集大量数据追加到events中
    const sendEvents = this.events.slice(0, options.value.cacheMaxLength) // 需要发送的事件
	this.events = this.events.slice(options.value.cacheMaxLength) // 剩下待发的事件

	// 构建发送参数
	const time = getTimestamp();
	const sendParams = computed(() => {
	  baseInfo: {
	    ...baseInfo.base?.value,
	    sendTime: time,
	    userUuid: options.value.userUuid
	  },
	  eventInfo: map(sendEvents, (e: any) => {
        e.sendTime = time
        return e
      })
	})

	// 本地化拦截, 如果开启了本地化存储，将数据存储到 localStorage
	if (options.value.localization) {
	  const success = LocalStorageUtil.setSendDataItem(
        SDK_LOCAL_KEY,
        sendParams.value
      );
      
	  // 如果存储失败，触发溢出回调
	  if (!success) options.value.localizationOverFlow(sendParams.value)
      return
	}

	// 经过前置钩子处理的最终数据
    const afterSendParams = executeFunctions(
      options.value.beforeSendData,
      false,
      sendParams.value
    )
    if (isFlase(afterSendParams)) return
    if (!this.validateObject(afterSendParams, 'beforeSendData')) return

	debug('send events', sendParams.value);

	this.executeSend(options.value.dsn, afterSendParams).then((res: any) => {
	  // 执行所有「发送后」Hook
      executeFunctions(options.value.afterSendData, true, {
        ...res,
        params: afterSendParams
      })
    })

	// 如果一次性发生的事件超过了阈值(cacheMaxLength)，那么这些经过裁剪的事件列表剩下的会直接发，并不会延迟等到下一个队列
	if (this.events.length) {
      nextTime(this.send.bind(this)) // 继续传输剩余内容,在下一个时间择机传输
    }
  }

  private executeSend(url: string, data) {
    let sendType = 1;
    if (options.value.sendTypeByXmlBody) {
      // 强制指定 xml body 形式
      sendType = 3
    } else if (_global.navigator) {
      // sendBeacon 最大64kb
      sendType = isObjectOverSizeLimit(data, 60) ? 3 : 1
    } else {
      // img 限制在 2kb
      sendType = isObjectOverSizeLimit(data, 2) ? 3 : 2
    }

	return new Promise(resolve => {
      switch (sendType) {
        case 1:
          resolve({ sendType: 'sendBeacon', success: sendByBeacon(url, data) })
          break
        case 2:
          sendByImage(url, data).then(() => {
            resolve({ sendType: 'image', success: true })
          })
          break
        case 3:
          sendByXML(url, data).then(() => {
            resolve({ sendType: 'xml', success: true })
          })
          break
      }
    })
  }
}

// 选取执行发送代码的理想时间
const nextTime =
  window.requestIdleCallback ||
  window.requestAnimationFrame ||
  (callback => setTimeout(callback, 17))
```

发送数据的三种方式
详细描述见：[[2 - 数据结构设计#监控上报时机|监控上报时机]]

sendBeacon
```js
export function sendByBeacon(url: string, data: any) {
  return navigator.sendBeacon(url, JSON.stringify(data))
}
```

Img
```js
export const sendReaconImageList = []

export function sendByImage(url: string, data: any): Promise<void> {
  return new Promise(resolve => {
    const beacon = new Image()
    beacon.src = `${url}?v=${encodeURIComponent(JSON.stringify(data))}`
    sendReaconImageList.push(beacon)
    beacon.onload = () => {
      // 发送成功
      resolve()
    }
    beacon.onerror = function () {
      // 发送失败
      resolve()
    }
  })
}
```
XML
```js
export function sendByXML(url: string, data: any): Promise<void> {
  return new Promise(resolve => {
    const xhr = new XMLHttpRequest()
    xhr.open('post', url)
    xhr.setRequestHeader('content-type', 'application/json')
    xhr.send(JSON.stringify(data))
    xhr.onreadystatechange = function () {
      if (xhr.readyState === 4) {
        resolve()
      }
    }
  })
}
```
### 网络监听
当处于断网状态下的所有埋点事件都无效（认为此时采集的数据大部分是无效的）
```js
class LineStatus {
  onLine = true
  
  constructor() {
    this.init()
  }

  init() {
	eventBus.addEvent({
      type: EVENTTYPES.OFFLINE,
      callback: e => {
        if (e.type === 'offline') {
          debug('网络断开')
          this.onLine = false
        }
      }
    });
    
    eventBus.addEvent({
      type: EVENTTYPES.ONLINE,
      callback: e => {
        if (e.type === 'online') {
          debug('网络连接')
          this.onLine = true
        }
      }
    })
  }
}
```

## 监控平台如何录屏
### 录制的时机和时长
### 内存管理和数据压缩
### 对性能的影响