完整的链路日志数据应该包含两部分：日志基础数据和问题信息数据。其中，基础数据有5大类：**基本日志信息、浏览器信息、页面信息、用户信息、业务信息**；问题数据包含**异常信息、性能数据、操作行为**三大块。
![[Pasted image 20240509135340.png]]
### 日志基础数据
```ts
// BaseTraceData 由五大类构成
type BaseTraceData = BaseTrace & BaseBrowserTrace & BaseUserTrace & BaseAppTrace & BasePageTrace

const exampleBaseData: BaseTraceData = {
  traceId: '0bdf6c8e-25c8-427d-847a-9950318a2e14',
  level: TraceLevelType.warn,
  type: TraceTypes.ACTION,
  ua: 'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/124.0.0.0 Safari/537.36',
  bt: BrowserType.MOBILE,
  fpId: 'c77a37f4',
  uid: 1002,
  // 例如：极客邦App的命名
  appId: 'geekbang-app',
  clientType: TraceClientTypes.iOS_H5,
  pid: '088c8a92-5a24-4144-9c37-310848c397e1',
  url: 'https://time.geekbang.org/',
  createdAt: '',
  updatedAt: '',
}
```
####  基本信息
```ts
// 全链路日志基类
type BaseTrace = {
  // 唯一ID，用户侧生成（前端通过uuid生成）
  traceId: string
  // 日志类型，覆盖各种日志场景，为枚举
  type: TraceTypes
  // 日志产生时间 （两个时间都是由前端生成）
  createdAt: string
  // 日志最后更新时间
  updatedAt: string
};

enum TraceTypes {
  // PVUV
  PAGE_VIEW = 'PageView',
  // Event
  EVENT = 'EVENT',
  // 性能
  PERF = 'Perf',
  // 资源
  RESOURCE = 'Resource',
  // 动作、行为类型
  ACTION = 'Action',
  // 请求类型
  FETCH = 'Fetch',
  // 代码错误
  CODE_ERROR = 'CodeError',
  // 日志
  CONSOLE = 'Console',
  // 其它
  CUSTOMER = 'Customer'
}
```
#### 浏览器信息
```ts
enum BrowserType {
  // 手机端浏览器
  MOBILE = 'mobile',
  // PC浏览器
  PC = 'pc',
  // webview
  WEBVIEW = 'webview',
  // 小程序
  MINI_PROGRAM = 'miniProgram'
}

// 浏览器相关字段基类
type BaseBrowserTrace = {
  // 当前浏览器的UserAgent
  ua: string
  // 浏览器类型
  bt: BrowserType
}
```
#### 页面信息
对于pid的理解：大多前端项目是基于 Vue 或 React 技术栈的SPA页面，常都加载页面一次后就不会加载第二次了，页面的切换都是采用静态路由方式进行的。pid 的设计方案是从用户输入网址访问页面加载成功后，直到下一次重新刷新页面前，这个时间周期范围内，只生成一次 UUID 值。从而保证，它能帮助我们快速查询某个用户当前访问一次前端页面时的所有链路日志，从而帮助前端同学判断用户在使用前端页面过程中有没有异常。
```ts
// 页面相关字段基类
type BasePageTrace = {
  // 页面ID
  pid: string
  // 页面标题
  title?: string
  // 当前页面URL
  url: string
}
```
#### 用户信息
对于fpId的理解：设计指纹 ID 的作用是把同一个用户未登录和已登录两个状态的操作日志关联起来，这样就能快速查询用户登录前后的全链路日志
![[Pasted image 20240523163648.png]]
```ts
// 用户相关字段基类
type BaseUserTrace = {
  // 指纹ID，fingerprintId
  fpId: string
  // 用户ID
  uid?: string | number
  // 用户名称
  userName?: string
  // 用户邮箱
  email?: string
}
```

如何生成fId呢？

开源库FingerprintJS是一个不错的选择，开源版本的识别率达到 40~60%，而商用版本的识别率则高到 99.5%，但是需要付费。如果想在小型的监控系统中接入，更推荐Canvas生成指纹的方式。

首先，浏览器需要支持Canvas，然后我们对Canvas进行初始化。
```js
const canvas = document.createElement('canvas'); 
const ctx = canvas.getContext("2d");
```
然后在Canvas上填充矩形和文字，并设置字体、颜色、位置等属性
```js
const txt = 'yktest'
ctx.textBaseline ="top"
ctx.font = "14px 'Arial'"

ctx.fillStyle = "#f60"
// 先画一个60x20矩形内容
ctx.fillRect(125, 1, 60, 20)
// 把字填充到矩形内
ctx.fillStyle = "#069"
ctx.fillText(txt, 2, 15);
```
采用社区提供的转换方案，将填充的矩形和文字的画布转换成 Base64 字符串
```js
const b64 = canvas.toDataURL().replace("data:image/png;base64,","");
const bin = atob(b64);
const crc = bin2hex(bin.slice(-16,-12));
```
这样就产生同一设备下、同一个浏览器的唯一标识。通过上述步骤，我们可以将整个过程封装一下
```js
type FingerprintOptions = {
  font?: string
  reactStyle?: string | CanvasGradient | CanvasPattern
  contentStyle?: string | CanvasGradient | CanvasPattern
  textBaseline?: CanvasTextBaseline
}

export const getFingerprintId = (content: string, options?: FingerprintOptions) => {
  if (!content) {
    console.error("content is empty");
    return null;
  }
  const canvas = document.createElement('canvas');
  const ctx = canvas.getContext("2d");
  // 如果不存在，则返回空值，说明不支持Canvas指纹
  if (!ctx) return null;

  const txt = content || 'geekbang';
  ctx.textBaseline = options && options.textBaseline ? options.textBaseline : "top";
  ctx.font = options && options.font ? options.font : "14px 'Arial'";

  ctx.fillStyle = options && options.reactStyle ? options.reactStyle : "#f60";
  // 先画一个60x20矩形内容
  ctx.fillRect(125, 1, 60, 20);

  ctx.fillStyle = options && options.contentStyle ? options.contentStyle : "#069";
  // 把字填充到矩形内
  ctx.fillText(txt, 2, 15);

  const b64 = canvas.toDataURL().replace("data:image/png;base64,","");
  const bin = atob(b64);
  const crc = bin2hex(bin.slice(-16,-12));
  return crc;
}
```
想要强调的是，Canvas指纹在小程序上不太适用，并且在不支持Canvas特性的浏览器上也不可以。这一技术也可能侵犯用户隐私，造成多套应用共享一个指纹的情况，从而针对用户推送类似的广告。
#### 业务信息
```ts
enum TraceLevelType {
  // 告警级别
  error = 'error',
  // 预警级别
  warn = 'warn',
  // 普通日志
  info = 'info',
  // 调试日志
  debug = 'debug'
}

enum TraceClientTypes {
  // 安卓
  ANDROID_H5 = 'android',
  // iOS
  IOS_H5 = 'ios',
  // PC端
  PC_H5 = 'pc',
  // 浏览器
  BROWSER_H5 = 'browser'
}

// 业务相关字段基类
type BaseAppTrace = {
  // 业务ID => 区分前端项目
  appId: string
  // 业务名称
  appName?: string
  // 客户端类型
  clientType: TraceClientTypes
  // 日志级别
  level: TraceLevelType
}
```
### 问题信息数据
大体的数据格式如下:
![[Pasted image 20250107164957.png]]
分别用 data 字段记录异常信息、perf 字段记录页面性能信息以及 breadcrumbs 字段记录用户操作行为
#### 异常信息
通用的数据字段如下: 
```js
type TraceBaseData = {
  // id 是对异常信息进行哈希后得出的字符串;如果出现大量相同的dataId，证明有通用性错误
  dataId: number
  // 日志信息名称
  name: string
  // 问题级别
  level: TraceDataSeverity
  // 异常信息
  message: string
  // 发生时间
  time: number
  // 问题类型
  type: TraceDataTypes
}

declare enum TraceDataSeverity {
  Else = 'else', // 其他
  Error = 'error', // 错误级别
  Warning = 'warning', // 告警级别
  Info = 'info', // 日志级别
  Debug = 'debug', // 调试级别
  Low = 'low', // 低危级别
  Normal = 'normal', // 普通级别
  High = 'high', // 高危级别
  Critical = 'critical', // 极其严重
}

declare enum TraceDataTypes {
  UNKNOWN = 'UNKNOWN',
  JAVASCRIPT = 'JAVASCRIPT',
  LOG = 'LOG',
  HTTP = 'HTTP',
  VUE = 'VUE',
  REACT = 'REACT',
  RESOURCE = 'RESOURCE',
  PROMISE = 'PROMISE',
  ROUTE = 'ROUTE',
  PERF = 'PERF'
}
```

##### 代码异常
```js
// 代码异常错误信息
type TractDataCodeError = TraceBaseData & {
  stack: [] // 记录堆栈信息
}
```
##### 网络请求
```js
// 请求类信息
type TraceDataFetch = TraceBaseData & {
  // 执行时间，用于统计耗时
  elapsedTime: number
  // 请求方法
  method: 'POST' | 'GET'
  // 请求类型
  httpType: 'fetch' | 'xhr'
  // 请求地址
  url: string
  // 请求参数
  body: string
  // 响应状态
  status: number
}
```
##### 其余字段
```js
// Promise类型
type TraceDataPromise = TraceBaseData

// 资源类型
type TraceDataResource = TraceBaseData

// 普通日志
type TraceDataLog = TraceBaseData & {
  tag: string
}

// PV/UV
type TraceDataPageView = TraceBaseData & {
  route: string
}
```
#### 页面性能
#### 操作行为
### 监控上报时机
#### Fetch 和 XHR
理论上可以，但实际存在几点限制
- Fetch 需要遵循同源策略。也就是说，跨域请求可能会因为浏览器的限制而请求失败
- Fetch 是新 Web 浏览器的特性和标准，要满足兼容旧版本浏览器，就需要采用 polyfill 的方式解决兼容问题，无形中给 SDK 增加了不少兼容性代码，造成负担
- 直接使用 Fetch 可能会受到网络波动或请求超时等因素影响，导致数据丢失或不准确
- XMLHttpRequest 是最早支持前端代码请求的方法，但需要封装更多的代码，而且还不支持 Promise。但因为它对低端浏览器的兼容性是最好的，所以，我们可以把它作为向下的兼容方案
#### sendBeacon
Beacon API，它可以给服务器发送异步和非阻塞请求，这类请求是不需要响应结果的。它最大的优势是浏览器会在保证页面卸载前就把请求发送完成。所以我们经常会利用它将分析数据发送给服务器。
```js
// src/core/util.ts
export function sendBeacon(url: string, data: TraceData) {
  if (typeof navigator === 'undefined') return
  navigator.sendBeacon && navigator.sendBeacon(url, JSON.stringify(data))
}
```
但是这个方法存在兼容性问题，像微信内置浏览器和微信小程序这两种场景Beacon API 就无法使用了，需要考虑使用其它方案
#### GIF
创建一个 Image 对象，并将其 src 属性设为“需要上报的 URL”就可以了。

解决了前面两个技术的兼容性问题和跨域问题，甚至还有一个明显的优点，就是不会阻塞页面加载，即使请求失败也不会影响用户对页面的正常交互体验
```js
// src/core/util.ts
export function sendByImg(url: string, data: TraceData) {
  const spliceStr = url.indexOf('?') === -1 ? '?' : '&'
  const imageUrl = `${url}${spliceStr}data=${encodeURIComponent(safeStringify(data))}`;
  let img = new Image()
  img.src = imageUrl
  img.onload = function() {
    console.log("Tracking data sent successfully!");
    img = null
  };
  img.onerror = function() {
    console.error("Failed to send tracking data.");
    img = null
  };
}
```